<!DOCTYPE html><html class="hide-aside" lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试整合（长期更新） | Green Park</title><meta name="author" content="6wensitan"><meta name="copyright" content="6wensitan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="自我介绍面试官好，我是彭春衡，很高兴有机会在这里向您介绍自己。 我来自广西科技大学本科应届毕业生，大学期间主修软件工程专业。在校期间，曾参加校级ACM比赛，并获得优胜奖。此外，我还在院级青年志愿者协会中任职活动部部长一年半，积极参与志愿服务活动，锻炼了自己的组织协调能力和团队合作精神。 个人优势主要体现在一下几个方面：  扎实的Java基础，熟悉集合&#x2F;io等技术 了解网络TCP&amp;#x2F">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整合（长期更新）">
<meta property="og:url" content="https://6wensitan.github.io/post/62089d08.html">
<meta property="og:site_name" content="Green Park">
<meta property="og:description" content="自我介绍面试官好，我是彭春衡，很高兴有机会在这里向您介绍自己。 我来自广西科技大学本科应届毕业生，大学期间主修软件工程专业。在校期间，曾参加校级ACM比赛，并获得优胜奖。此外，我还在院级青年志愿者协会中任职活动部部长一年半，积极参与志愿服务活动，锻炼了自己的组织协调能力和团队合作精神。 个人优势主要体现在一下几个方面：  扎实的Java基础，熟悉集合&#x2F;io等技术 了解网络TCP&amp;#x2F">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.pixabay.com/photo/2023/08/23/12/57/young-8208513_640.jpg">
<meta property="article:published_time" content="2023-09-23T06:14:37.000Z">
<meta property="article:modified_time" content="2023-12-25T09:38:36.654Z">
<meta property="article:author" content="6wensitan">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.pixabay.com/photo/2023/08/23/12/57/young-8208513_640.jpg"><link rel="shortcut icon" href="/img/nnwm.jpg"><link rel="canonical" href="https://6wensitan.github.io/post/62089d08.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试整合（长期更新）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-25 17:38:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/nnwm.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.pixabay.com/photo/2023/08/23/12/57/young-8208513_640.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Green Park"><span class="site-name">Green Park</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试整合（长期更新）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-23T06:14:37.000Z" title="发表于 2023-09-23 14:14:37">2023-09-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-25T09:38:36.654Z" title="更新于 2023-12-25 17:38:36">2023-12-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/">面试专题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>面试官好，我是彭春衡，很高兴有机会在这里向您介绍自己。</p>
<p>我来自广西科技大学本科应届毕业生，大学期间主修软件工程专业。在校期间，曾参加校级ACM比赛，并获得优胜奖。此外，我还在院级青年志愿者协会中任职活动部部长一年半，积极参与志愿服务活动，锻炼了自己的组织协调能力和团队合作精神。</p>
<p><strong>个人优势主要体现在一下几个方面：</strong></p>
<ul>
<li>扎实的Java基础，熟悉集合&#x2F;io等技术</li>
<li>了解网络TCP&#x2F;ip协议，http和https</li>
<li>熟悉MySQL、掌握MyBatis&#x2F;Spring &#x2F;springmvc&#x2F;springboot,掌握jwt令牌处理</li>
<li>了解基本的linux指令，docker的基本部署指令；熟悉Maven的项目管理，熟悉git、svn的版本控制。</li>
</ul>
<p><strong>个人项目经历：我曾参加过两个项目的开发，分别是交互式聊天机器人和一个农产品溯源系统。</strong></p>
<ul>
<li>在聊天机器人的项目中，使用Java和SpringBoot框架来构建后端服务，利用MyBatis作为持久层框架，使用MySQL数据库来存储用户信息、聊天记录和其他相关数据。</li>
<li>在溯源项目中，我采用Java和SpringBoot框架来处理农产品种类、产地、养殖方式等信息的增删改查，再者使用MyBatis框架、MySQL数据库、jwt令牌身份效验、拦截器等技术，实现农产品从生产到消费的信息追溯。</li>
</ul>
<p><strong>最后我一直在努力的学习技术，我希望能够在贵公司工作学习。</strong></p>
<h1 id="发展规划"><a href="#发展规划" class="headerlink" title="发展规划"></a>发展规划</h1><p>现阶段是</p>
<ul>
<li>继续<strong>深化</strong>对Java基础知识的学习，熟悉Java的最新特性。</li>
<li><strong>深入学习</strong>并发编程、网络编程等技术，提高自己的技术能力。</li>
<li><strong>积累项目经验</strong>，提高自己的工程能力。</li>
<li><strong>拓展自己的知识面</strong>，了解其他相关技术</li>
</ul>
<p>希望在<strong>以后</strong>的学习工作中：</p>
<ul>
<li><code>在工作中</code>，可以积极参与项目开发，在实践中积累经验。</li>
<li><code>在业余时间</code>，可以参加线上或线下的培训，学习新技术。</li>
<li>可以阅读相关书籍和文章，拓展自己的知识面。</li>
</ul>
<h1 id="工作期望"><a href="#工作期望" class="headerlink" title="工作期望"></a>工作期望</h1><p>我<strong>希望</strong>能一家有潜力的公司工作，本身我对Java的学习兴趣浓厚，希望自己能在技术方面能有所进步，努力成为一名Java开发师。</p>
<p>我目前的<strong>薪酬期望</strong>在于8-10k左右，工作地点可以根据公司的情况而定。</p>
<p>我相信凭借我的努力和热情，能够在<strong>贵公司</strong>取得一个不错的成绩。</p>
<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><hr>
<h2 id="浅析Java中volatile关键字及其作用"><a href="#浅析Java中volatile关键字及其作用" class="headerlink" title="浅析Java中volatile关键字及其作用"></a>浅析Java中volatile关键字及其作用</h2><hr>
<p>在Java多线程如何保证线程的安全性？我们可以使用“Synchronized”同步锁保证线程安全。（弊端：消耗资源）</p>
<p>首先得了解：多线程和JVM</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h5 id="进程和线程的概念"><a href="#进程和线程的概念" class="headerlink" title="进程和线程的概念"></a>进程和线程的概念</h5><ul>
<li>进程：一个正在执行的程序，<strong>动态的</strong>，是系统进行资源分配和调度的独立<strong>单位</strong>。</li>
<li>进程中一个独立的控制单元，线程控制着进程的执行，。<strong>一个进程中至少有一个线程</strong></li>
</ul>
<h5 id="线程的两种方式（创建）"><a href="#线程的两种方式（创建）" class="headerlink" title="线程的两种方式（创建）"></a>线程的两种方式（创建）</h5><ul>
<li><p>继承Thread类：定义继承Thread类、重写run方法、调用该线程start方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// step2：创建该类的对象</span></span><br><span class="line">		<span class="type">Lefthand</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lefthand</span>();</span><br><span class="line">		<span class="type">Righthand</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Righthand</span>();</span><br><span class="line">		<span class="comment">// step3：调用start方法启动线程</span></span><br><span class="line">		left.start();</span><br><span class="line">		right.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// step1：继承Thread类，在子类中必须实现run方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lefthand</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;You are Students!&quot;</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				sleep(<span class="number">500</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Righthand</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;I am a Teacher!&quot;</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				sleep(<span class="number">300</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现Runnable接口：定义实现Runnable接口、实现run方法、通过Thread类建立线程对象、start方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoThreadsDemo2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">SimpleThread2</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleThread2</span>(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">		<span class="type">SimpleThread2</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleThread2</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">		<span class="comment">// step3</span></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(th1);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(th2);</span><br><span class="line">		thread1.start();</span><br><span class="line">		thread2.start();</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// step1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SimpleThread2</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		name = str;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// step2</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">			System.out.println(i + <span class="string">&quot; &quot;</span> + name);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;DONE!&quot;</span> + name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意两种方式区别：第二种避免单继承的局限性，线程代码存在接口子类型中。</p>
</blockquote>
</li>
</ul>
<h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><ul>
<li>就绪状态（创建线程）、可执行线程（start启动线程，调用run方法）、阻塞状态（sleep和wait）、死亡状态（stop）</li>
</ul>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h5 id="JVM-的概念"><a href="#JVM-的概念" class="headerlink" title="JVM 的概念"></a>JVM 的概念</h5><ul>
<li>Java虚拟机定义是抽象的规范，使Java可以具有跨平台的运行。他<strong>决定一个线程对共享变量的写入何时对另一个线程可见性</strong></li>
</ul>
<h5 id="JVM的结构组成部分"><a href="#JVM的结构组成部分" class="headerlink" title="JVM的结构组成部分"></a>JVM的结构组成部分</h5><ul>
<li><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/70.png" alt="img"></li>
<li>主内存：线程共享（本体）</li>
<li>工作内存：线程私有（副本）</li>
<li>线程对共享变量的所有操作全在工作内存中进行；变量值的传递只能在主内存中完成。</li>
</ul>
<h3 id="volatile关键字作用"><a href="#volatile关键字作用" class="headerlink" title="volatile关键字作用"></a>volatile关键字作用</h3><h5 id="内存可见性（不能保证变量的原子性）"><a href="#内存可见性（不能保证变量的原子性）" class="headerlink" title="内存可见性（不能保证变量的原子性）"></a>内存可见性（不能保证变量的原子性）</h5><ul>
<li><p>某线程对volatile修饰变量的修改，其他线程是可见的，每次获取该变量都是最新的值。</p>
</li>
<li><p>该特性体现Java原则之一：先行发生原则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//线程 A 在其工作内存中写入变量 a 的新值 1</span></span><br><span class="line">a = <span class="number">1</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程 B 在主内存中读取变量 a 的值输出</span></span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用该关键字并体现该特性的条件：</p>
<p>​			1、能确保只有单一的线程对共享变量的只进行修改</p>
<p>​			2、变量不需要和其他状态共同参与不变的约束条件</p>
</blockquote>
</li>
</ul>
<h5 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h5><ul>
<li><p>指令重排：JVM在编译Java代码时或者CPU在执行JVM字节码时，对现有指令进行重新排序（前提是不改变程序结果），优化运行效率。</p>
</li>
<li><p>执行排序的约束，（解决多线程问题）-》<strong>内存屏障</strong></p>
</li>
<li><p>内存屏障是一种屏障指令，分四种类型：LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障；</p>
</li>
<li><p>针对于volatile变量上的体现：（JVM执行）</p>
<ul>
<li>对每一个volatile变量写入前：<strong>StoreStore屏障</strong></li>
<li>对写之后：<strong>StoreLoad屏障</strong></li>
<li>对读操作之前：<strong>LoadLoad屏障</strong></li>
<li>对读之后：<strong>LoadStore屏障</strong></li>
</ul>
</li>
<li><p>不能保证线程安全性</p>
</li>
</ul>
<h3 id="对于本节内容的总结："><a href="#对于本节内容的总结：" class="headerlink" title="对于本节内容的总结："></a>对于本节内容的<strong>总结</strong>：</h3><ul>
<li>volatile具有内存可见性，基于屏障指令；</li>
<li>volatile具有禁止指令重排，在编译时：JVM遵循内存屏障的约束，运行时：屏障指令组织重排。</li>
<li>Synchronized关键字：保证变量原子性和可见性；volatile不能保证原子性、线程不安全</li>
</ul>
<h2 id="数据结构–二叉树的先中后序遍历"><a href="#数据结构–二叉树的先中后序遍历" class="headerlink" title="数据结构–二叉树的先中后序遍历"></a>数据结构–二叉树的先中后序遍历</h2><hr>
<h3 id="二叉树的递归特性"><a href="#二叉树的递归特性" class="headerlink" title="二叉树的递归特性"></a>二叉树的递归特性</h3><ul>
<li>空二叉树</li>
<li>根节点+左子树+右子树组成的二叉树</li>
</ul>
<h3 id="三种遍历方式："><a href="#三种遍历方式：" class="headerlink" title="三种遍历方式："></a>三种遍历方式：</h3><blockquote>
<p>注意：该遍历方式也是一种递归的方式</p>
</blockquote>
<ul>
<li>先序（前序）：根左右（NLR）<ul>
<li>先访问<strong>根</strong>节点，再访问该根节点的左子树节点，最后该根节点的右子树；当然该左子树或右子树分支节点，也根据此遍历方式。</li>
</ul>
</li>
<li>中序：左根右（LNR）<ul>
<li>先访问<strong>左子树</strong>节点，再到<strong>根</strong>节点，最后才是右子树节点；当然还有分支也是如此遍历下去。</li>
</ul>
</li>
<li>后序：左右根（LRN）<ul>
<li>先访问左子树节点，再到<strong>右子树</strong>节点，最后根子数节点；当然还有分支也是如此遍历下去。</li>
</ul>
</li>
</ul>
<p><strong>下面是图例：</strong></p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/97c72517666e46448a3ceb29cc807c2a.png" alt="img"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h5 id="先序遍历代码"><a href="#先序遍历代码" class="headerlink" title="先序遍历代码"></a>先序遍历代码</h5><ul>
<li><p>若二叉树为null，则什么也不做</p>
</li>
<li><p>非空时：先访问根节点；先序遍历左子树；先序遍历右子树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		visit(T);                访问根结点，visit()执行相关访问操作的函数，比如打印...</span><br><span class="line">		PreOrder(T-&gt;lchild);     <span class="comment">//递归遍历左子树</span></span><br><span class="line">		PreOrder(T-&gt;rchild);     <span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="中序遍历代码"><a href="#中序遍历代码" class="headerlink" title="中序遍历代码"></a>中序遍历代码</h5><ul>
<li><p>二叉树&#x3D;null，什么也不做</p>
</li>
<li><p>二叉树！&#x3D;null：先访问左子树节点，再到根节点，最后右子树节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		InOrder(T-&gt;lchild);		<span class="comment">//递归遍历左子树</span></span><br><span class="line">		visit(T);				<span class="comment">//访问根结点</span></span><br><span class="line">		InOrder(T-&gt;rchild);		<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="后序遍历代码"><a href="#后序遍历代码" class="headerlink" title="后序遍历代码"></a>后序遍历代码</h5><ul>
<li><p>二叉树&#x3D;null，什么也不做</p>
</li>
<li><p>二叉树！&#x3D;null：先访问左子树节点，再到右子树节点，最后根节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		PostOrder(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">		PostOrder(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">		visit(T);				<span class="comment">//访问根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="应用-求树的深度"><a href="#应用-求树的深度" class="headerlink" title="应用:求树的深度"></a>应用:求树的深度</h5><ul>
<li><p>后序遍历算法改编：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">		<span class="type">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">		<span class="keyword">return</span> l &gt; r ? l + <span class="number">1</span> : r + <span class="number">1</span>;		<span class="comment">//树的深度=Max(左子树深度,右子树深度)+1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="区别时间复杂度和空间复杂度"><a href="#区别时间复杂度和空间复杂度" class="headerlink" title="区别时间复杂度和空间复杂度"></a>区别时间复杂度和空间复杂度</h1><hr>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h3><blockquote>
<p>T（n）&#x3D;O（f（n））</p>
<p>T表示算法执行时间，n表示数据规模；成正比的计算</p>
</blockquote>
<h5 id="如何理解时间复杂度"><a href="#如何理解时间复杂度" class="headerlink" title="如何理解时间复杂度"></a>如何理解时间复杂度</h5><ul>
<li>表示代码的执行时间随着数据规模的增长趋势，而不是具体的执行时间</li>
<li>通常只是表示数据规模n很大的时候的执行效率</li>
</ul>
<h5 id="如何计算时间复杂度"><a href="#如何计算时间复杂度" class="headerlink" title="如何计算时间复杂度"></a>如何计算时间复杂度</h5><ul>
<li>忽略常量、系数、只保留最高量级</li>
<li>总时间复杂度&#x3D;量级最大代码的执行时间复杂度</li>
<li><strong>嵌套代码的复杂度&#x3D;嵌套内外复杂度的乘积</strong></li>
</ul>
<h5 id="常见的几种时间复杂度"><a href="#常见的几种时间复杂度" class="headerlink" title="常见的几种时间复杂度"></a>常见的几种时间复杂度</h5><ul>
<li>O(1)：常量级：Hash表上的各种操作</li>
<li><strong>O(logn)<strong>：对数级：</strong>二分查找</strong>、调表</li>
<li>O(n)：线性：数组，链表<strong>遍历</strong></li>
<li><strong>O(nlogn)<strong>：快排、</strong>归并排序</strong></li>
<li><strong>O(n^2)：冒泡、插入、选择排序</strong></li>
<li>O(2^n)：指数级：回溯穷举法</li>
<li>O(n!)：求全排列</li>
</ul>
<h5 id="最好-最坏-平均时间复杂度"><a href="#最好-最坏-平均时间复杂度" class="headerlink" title="最好\最坏\平均时间复杂度"></a>最好\最坏\平均时间复杂度</h5><blockquote>
<p>例子：在数组中找某个值，遍历的情况</p>
</blockquote>
<ul>
<li>最好时间复杂度<ul>
<li>O(1)。（接口的最小相应时间）</li>
</ul>
</li>
<li>最坏时间复杂度<ul>
<li>O(n)。（最大）</li>
</ul>
</li>
<li>平均时间复杂度<ul>
<li>O(n)。（平均）–大多数情况下：平均就是最坏的时间复杂度</li>
</ul>
</li>
<li>均摊时间复杂度<ul>
<li>是特殊的平均时间复杂度，常见：动态扩容</li>
</ul>
</li>
</ul>
<h3 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h3><h5 id="如何理解空间复杂度"><a href="#如何理解空间复杂度" class="headerlink" title="如何理解空间复杂度"></a>如何理解空间复杂度</h5><ul>
<li>是度量算法运行过程占用的存储空间，通常使用S（n）表示，n表示问题的规模。</li>
</ul>
<h5 id="常见空间复杂度："><a href="#常见空间复杂度：" class="headerlink" title="常见空间复杂度："></a>常见空间复杂度：</h5><ul>
<li><p>O(1)：代码中m\n所分配的空间都是常量级的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>


</li>
<li><p>O(n)：代码中使用array数组保存变量，随着n的值增大，数组所占空间也越大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[n]</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   array[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="判别Java-IO流的使用区别，以及使用场景"><a href="#判别Java-IO流的使用区别，以及使用场景" class="headerlink" title="判别Java IO流的使用区别，以及使用场景"></a>判别Java IO流的使用区别，以及使用场景</h1><hr>
<h2 id="面向字节输入-输出流"><a href="#面向字节输入-输出流" class="headerlink" title="面向字节输入&#x2F;输出流"></a>面向字节输入&#x2F;输出流</h2><h3 id="面向字节的输入流"><a href="#面向字节的输入流" class="headerlink" title="面向字节的输入流"></a>面向字节的输入流</h3><blockquote>
<p>在java.io包下，InputStream类表示字节输入流，特点：抽象、不能实例化、。面向字节的输入流都是该类的子类</p>
</blockquote>
<p>如下图：</p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjEyMjI3MQ==,size_16,color_FFFFFF,t_70.png" alt="1111111"></p>
<h4 id="文件输入流（FileInputStream）"><a href="#文件输入流（FileInputStream）" class="headerlink" title="文件输入流（FileInputStream）"></a>文件输入流（FileInputStream）</h4><ul>
<li><p>用于读取二进制文件数据，利用new创建对象，构造方法有：</p>
<ul>
<li><p>FileInputStream（File file）：打开一个实际文件链接来创建文件输入流，有文件系统的File对象指定。</p>
</li>
<li><p>FileInputStream（String name）：根据文件系统的路径名name指定读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			FileInputStream file=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;e:/新建文本文档.txt&quot;</span>);    <span class="comment">//创建一个FileInputStream类实例对象file</span></span><br><span class="line">			<span class="type">int</span> byteRead=file.read();            <span class="comment">//创建一个byteRead变量存储读一个字节</span></span><br><span class="line">			<span class="keyword">while</span>(byteRead!=-<span class="number">1</span>) &#123;                <span class="comment">//如果返回值不是-1则继续执行file的读操作</span></span><br><span class="line">				System.out.print((<span class="type">char</span>)byteRead);    <span class="comment">//将int类型转换为char类型并输出</span></span><br><span class="line">				byteRead=file.read();    </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;        <span class="comment">//访问数组元素下标越界的异常</span></span><br><span class="line">			System.out.println(<span class="string">&quot;要一个文件名作为命令行参数！&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(FileNotFoundException e) &#123;                 <span class="comment">//访问文件不存在的异常</span></span><br><span class="line">			System.out.println(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;&#125;                          <span class="comment">//输入输出异常</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="字节数组输入流（ByteArraryInputStream）"><a href="#字节数组输入流（ByteArraryInputStream）" class="headerlink" title="字节数组输入流（ByteArraryInputStream）"></a>字节数组输入流（ByteArraryInputStream）</h4><ul>
<li><p>从内存的字节数组中读取数据(数据源是一个字节数组),把字节数组转为输入流类型</p>
<ul>
<li><p>采用<strong>适配器设计模式</strong>,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		String str=<span class="string">&quot;123456789qwerty&quot;</span>;        <span class="comment">//创建一个字符串变量</span></span><br><span class="line">		<span class="type">byte</span>[]strBuf=str.getBytes();         <span class="comment">//把字符串转换为字节数组</span></span><br><span class="line">		ByteArrayInputStream bais=<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(strBuf);    <span class="comment">//创建一个字节数组流对象</span></span><br><span class="line">		<span class="type">int</span> data=bais.read();                 <span class="comment">//从字节数组输入流读取字节</span></span><br><span class="line">		<span class="keyword">while</span>(data!=-<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">char</span> upper=Character.toUpperCase((<span class="type">char</span>)data);    <span class="comment">//小写转换为大写</span></span><br><span class="line">			System.out.print(upper+<span class="string">&quot; &quot;</span>);</span><br><span class="line">			data=bais.read();                 <span class="comment">//读取字节</span></span><br><span class="line">		&#125;</span><br><span class="line">		bais.close();                         <span class="comment">//关闭字节数组输入流</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> Q W E R T Y </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="数据输入流（DataInputStream）"><a href="#数据输入流（DataInputStream）" class="headerlink" title="数据输入流（DataInputStream）"></a>数据输入流（DataInputStream）</h4><h3 id="面向字节的输出流"><a href="#面向字节的输出流" class="headerlink" title="面向字节的输出流"></a>面向字节的输出流</h3><blockquote>
<p> 面向字节的输出流都是类OutputStream的后代类</p>
</blockquote>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjEyMjI3MQ==,size_16,color_FFFFFF,t_70-16954594534474.png" alt="132543"></p>
<h4 id="文件输出流（FileOutputStream）"><a href="#文件输出流（FileOutputStream）" class="headerlink" title="文件输出流（FileOutputStream）"></a>文件输出流（FileOutputStream）</h4><ul>
<li><p>向二进制文件写入数据,构造方法:</p>
<ul>
<li>FileOutputStream(String name,boolean append):创建一个向指定名字的文件写入数据,若第二个参数为true,则添加方式写入字节,且文件中原有数据不删除;</li>
<li>FileOutputStream(File file,boolean):创建一个向指定File对象表示的文件中写入数据流,若第二个参数为true,则将字节写入文件末尾;</li>
</ul>
<p>实例:使用文件输入流将100-200之间可以被3整除的数写到文本中,要求每一行10个.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="type">int</span> n,num,i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/t.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">for</span>(n=<span class="number">100</span>;n&lt;=<span class="number">200</span>;n++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">0</span>) &#123;</span><br><span class="line">					i++;</span><br><span class="line">					String str=String.valueOf(n);</span><br><span class="line">					String str1=str+<span class="string">&quot; &quot;</span>;</span><br><span class="line">					<span class="type">byte</span>[]buff=str1.getBytes();</span><br><span class="line">					fos.write(buff);</span><br><span class="line">					<span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">0</span>) &#123;</span><br><span class="line">						str=<span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">						<span class="type">byte</span>[]buf=str.getBytes();</span><br><span class="line">						fos.write(buf);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			fos.close();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(FileNotFoundException e1) &#123;</span><br><span class="line">			System.out.println(e1);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e2) &#123;</span><br><span class="line">			System.out.println(e2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjEyMjI3MQ==,size_16,color_FFFFFF,t_70-16954600188656.png" alt="1231231"></p>
</li>
</ul>
<h4 id="字节数组输出流（ByteArrayOutputStream）"><a href="#字节数组输出流（ByteArrayOutputStream）" class="headerlink" title="字节数组输出流（ByteArrayOutputStream）"></a>字节数组输出流（ByteArrayOutputStream）</h4><ul>
<li><p>向内存的字节数组写入数据，它也采用了适配器设计模式，把字节数组类型转换为输出流类型，使程序能对字节数组进行写操作。其构造方法为：</p>
<ul>
<li><p>ByteArrayOutputStream()：创建一个新的字节数组输出流；</p>
</li>
<li><p>ByteArrayOutputStream(int size)：创建指定大小缓冲区的字节数组输出流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		ByteArrayOutputStream baos=<span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">		String s=<span class="string">&quot;Welcome to java&quot;</span>;</span><br><span class="line">		<span class="type">byte</span>[]buf=s.getBytes();</span><br><span class="line">		baos.write(buf);</span><br><span class="line">		System.out.println(baos.toString());</span><br><span class="line">		<span class="type">byte</span>[]b=baos.toByteArray();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;b.length;i++) &#123;</span><br><span class="line">			System.out.print((<span class="type">char</span>)b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Welcome to java</span><br><span class="line">Welcome to java</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="数据输出流（DataOutputStream）"><a href="#数据输出流（DataOutputStream）" class="headerlink" title="数据输出流（DataOutputStream）"></a>数据输出流（DataOutputStream）</h4><h2 id="面向字符输入-输出流"><a href="#面向字符输入-输出流" class="headerlink" title="面向字符输入&#x2F;输出流"></a>面向字符输入&#x2F;输出流</h2><blockquote>
<p>面向字符的输入输出流类都是Reader&#x2F;Writer类的子类</p>
</blockquote>
<p>如下图：</p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjEyMjI3MQ==,size_16,color_FFFFFF,t_70-16955389035348.png" alt="123131231"></p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjEyMjI3MQ==,size_16,color_FFFFFF,t_70-169553897806310.png" alt="34636545"></p>
<blockquote>
<p>对于这两个父类来说：都是抽象类，和前面的面向字节的父类提供的方法相似，只是将基于byte的参数改为基于char</p>
</blockquote>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><blockquote>
<p>Java可以将字节流和字符流互相转换</p>
</blockquote>
<h4 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h4><ul>
<li><p>Reader类和Writer类默认在本地平台字符编码和Unicode码的转换：</p>
<ul>
<li>Reader：将输出流中的其他编码转为<strong>Unicode</strong>，再分配。</li>
<li>Writer：将内存中的Unicode码转为其他编码，再写到输出流中。</li>
</ul>
</li>
<li><p><strong>采用特定类型编码的字节流：</strong></p>
<ul>
<li><p>InputStreamReader类：将一个字节中的若干个字节解码-》字符</p>
<ul>
<li><p>构造方法有:</p>
<ul>
<li>InputStreamReader（InputStream in）：默认字符编码，将字节输入流转为<strong>字符输入流</strong>并读取数据</li>
<li>InputStreamReader（InputStream in ，Charset c）：指定编码从输入流中读取数据</li>
<li>InputStreamReader（InputStream in ,String enc）throws Exception ：指定编码，将字节输入流转为字符输入流，并读取数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		String filename=<span class="string">&quot;D:/welcome.txt&quot;</span>;        <span class="comment">//创建一个变量filename存放文件路径</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			InputStreamReader isr=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename),<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">//创建转换输入流，按UTF-8的编码从输入流读取数据</span></span><br><span class="line">			<span class="type">int</span> c;                               <span class="comment">//创建int类型变量c</span></span><br><span class="line">			<span class="keyword">while</span>((c=isr.read())!=-<span class="number">1</span>)            <span class="comment">//使用while循环读取文件数据</span></span><br><span class="line">				System.out.print((<span class="type">char</span>)c);       <span class="comment">//输出打印字符</span></span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;                  </span><br><span class="line">			e.printStackTrace();                 <span class="comment">//查看完整错误信息</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>OutputStreamReader类：将字符-》编码成若干个字节，最后写入一个字节流。</p>
<ul>
<li><p>类比于上面的方法内容.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		String filename=<span class="string">&quot;D:/welcome.txt&quot;</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			OutputStreamWriter osw=<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filename),<span class="string">&quot;UTF-8&quot;</span>);    <span class="comment">//创建转换输出流</span></span><br><span class="line">			osw.write(<span class="string">&quot;Hello，一个想当英雄的男人！！！&quot;</span>);    <span class="comment">//向文本文件写入数据</span></span><br><span class="line">   			osw.close();                <span class="comment">//关闭文件</span></span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;    </span><br><span class="line">			e.printStackTrace();        <span class="comment">//查看所有错误信息</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h4><ul>
<li>往往在实际应用中：标准键盘输入&#x3D;字节；</li>
<li>当然如果想要一次性输入一行字符串，可以使用BufferedReader对字符流进行包装处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));    </span><br><span class="line">String  x=in.readLine();                <span class="comment">//读取一行字符串</span></span><br></pre></td></tr></table></figure>

<h2 id="使用区别：FileWriter—FileReader类"><a href="#使用区别：FileWriter—FileReader类" class="headerlink" title="使用区别：FileWriter—FileReader类"></a>使用区别：FileWriter—FileReader类</h2><h4 id="FileWriter："><a href="#FileWriter：" class="headerlink" title="FileWriter："></a>FileWriter：</h4><blockquote>
<p>用于<strong>写</strong>字符文件，通常将对象看成一个以字符为单位的无格式字符输出流</p>
</blockquote>
<ul>
<li><p>FileWriter(File file,boolean append)throws IOException：根据File对象构造一个FileWriterx对象，若第二个参数为true,则将字符以添加的方式写入文件尾处，若为false!则原有文件内容被清除；</p>
</li>
<li><p>FileWriter(String fileName,boolean append)throws IOException：根据字符串文件名构造一个FileWriter&gt;对象，若第二个参数为true,则将字符以添加的方式写入文件尾处，若为flse则原有文件内容被清除。</p>
<p><strong>实例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">//将九九乘法表写入文本文件中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">		String filename=<span class="string">&quot;D:/table.txt&quot;</span>;        </span><br><span class="line">		FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filename,<span class="literal">true</span>);    <span class="comment">//创建FileWriter对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) &#123;                         <span class="comment">//利用两个for循环打印九九乘法表</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">				String s=i+<span class="string">&quot;*&quot;</span>+j+<span class="string">&quot;=&quot;</span>+j*i+<span class="string">&quot; &quot;</span>;</span><br><span class="line">				fw.write(s);                            <span class="comment">//将乘法表写入文本文件中</span></span><br><span class="line">			&#125;</span><br><span class="line">			fw.write(<span class="string">&quot;\r\n&quot;</span>);                           <span class="comment">//写入回车换行符</span></span><br><span class="line">		&#125;</span><br><span class="line">		fw.flush();                                     <span class="comment">//强制刷新流</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="FileReader："><a href="#FileReader：" class="headerlink" title="FileReader："></a>FileReader：</h4><blockquote>
<p>用于<strong>读取</strong>字符文件，将对象看成一个以字符为基本单位的无格式字符输入流</p>
</blockquote>
<ul>
<li><p>以下构造方法和上面的输出流实相似的，所以直接上实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">		FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:/table.txt&quot;</span>);   <span class="comment">//创建FileReader对象</span></span><br><span class="line">		<span class="type">int</span> c;</span><br><span class="line">		<span class="keyword">while</span>((c=fr.read())!=-<span class="number">1</span>) &#123;                <span class="comment">//读取文件中的内容</span></span><br><span class="line">			System.out.print((<span class="type">char</span>)c);            <span class="comment">//将c转换为char类型并输出文件中的内容</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="常用的包装流：BufferedWriter–BufferedReader类"><a href="#常用的包装流：BufferedWriter–BufferedReader类" class="headerlink" title="常用的包装流：BufferedWriter–BufferedReader类"></a>常用的包装流：BufferedWriter–BufferedReader类</h2><h4 id="BufferedWriter："><a href="#BufferedWriter：" class="headerlink" title="BufferedWriter："></a>BufferedWriter：</h4><blockquote>
<p>是带缓冲的字符流（缓冲流），可以用以文本行为为单位处理文本。</p>
</blockquote>
<ul>
<li><p>以下是比较常用的方法：</p>
<ul>
<li><p>BufferedWriter(Vriter out):将输出流out转换成带缓冲的字符流，缓冲区大小为<strong>系统默认</strong>的：</p>
</li>
<li><p>BufferedWriter(Writer out,int sz):将流out转换成带缓冲的字符流，缓冲区大小为<strong>sz</strong>;</p>
</li>
<li><p>void newLine()throws IOException:<strong>写入行结束标记</strong>，该标记不是简单的换行符（八n’),而是由系统定义的属性Iine.separator。</p>
<p><strong>实例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">//将100以内所有的质数写入文本文件，要求每10个数一行。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/<span class="number">2</span>;i++)          <span class="comment">//判断是否为质数</span></span><br><span class="line">			<span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">		BufferedWriter bw=<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D:/number.txt&quot;</span>));  <span class="comment">//创建BufferedWriter对象</span></span><br><span class="line">		<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(isPrime(i)) &#123;</span><br><span class="line">				j++;</span><br><span class="line">				String s=String.valueOf(i);</span><br><span class="line">				String s1=s+<span class="string">&quot; &quot;</span>;</span><br><span class="line">				bw.write(s1);            <span class="comment">//写入数据到文本文件中</span></span><br><span class="line">				<span class="keyword">if</span>(j==<span class="number">10</span>) &#123;                    </span><br><span class="line">					j=<span class="number">0</span>;                 </span><br><span class="line">					bw.newLine();        <span class="comment">//当j=10时，写入一个换行符</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bw.flush();                      <span class="comment">//强制刷新流</span></span><br><span class="line">		bw.close();                      <span class="comment">//关闭文本文件</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="BufferedReader："><a href="#BufferedReader：" class="headerlink" title="BufferedReader："></a>BufferedReader：</h4><blockquote>
<p>此处也是带缓冲的字符流,可以将以文本行为为单位处理文本的场合.</p>
</blockquote>
<ul>
<li><p>常用方法和BufferedWriter的方法相似,</p>
<p><strong>实例代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">second</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:/number.txt&quot;</span>));    <span class="comment">//创建BufferedReader对象</span></span><br><span class="line">		<span class="type">int</span> c;                            <span class="comment">//创建int型变量c</span></span><br><span class="line">		<span class="keyword">while</span>((c=br.read())!=-<span class="number">1</span>)          <span class="comment">//判断是否读完文本中的数据</span></span><br><span class="line">			System.out.print((<span class="type">char</span>)c);    <span class="comment">//将int型转换为char型并输出</span></span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="非常好用的写入流：PrintWriter类"><a href="#非常好用的写入流：PrintWriter类" class="headerlink" title="非常好用的写入流：PrintWriter类"></a>非常好用的写入流：PrintWriter类</h2><blockquote>
<p>当需要以Java的基本数据类型为单位写入文本文件时,使用该PrintWriter类,进行此类文本的输出.</p>
</blockquote>
<ul>
<li><p>构造方法有以下几种：</p>
<ul>
<li>PrintWriter(Writer out)：将<strong>任意一个字符输出流</strong>out串接成一个PrintWriter对象，不自动刷空流：</li>
<li>PrintWriter(Writer out,<strong>boolean autoFlush</strong>)：将任意一个字符输出流out串接成一个PrintWriter对象，<strong>若boolean值为true，则自动刷空流；</strong></li>
<li>PrintWriter(OutputStream out)：将任意一个字符输出流out串接成一个PrintWriter对象，不自动刷空流；</li>
<li>PrintWriter(OutputStream out,boolean autoFlush)：将任意一个字节输出流out串接成一个PrintWriter对象，若boolean值为true，则自动刷空流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">//如果一个四位数是11的倍数且十位数字加上百位数字刚好等于前位数字，则将该四位数写入文本文件中。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">printWriter</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException&#123;</span><br><span class="line">		FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D:/four.txt&quot;</span>);    <span class="comment">//创建FileWriter对象</span></span><br><span class="line">		PrintWriter pw=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(fw);             <span class="comment">//创建PrintWriter对象</span></span><br><span class="line">		<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1000</span>;i&lt;<span class="number">10000</span>;i++) &#123;                   <span class="comment">//利用for循环获得各个位的数字</span></span><br><span class="line">			<span class="type">int</span> A=i/<span class="number">1000</span>;                               <span class="comment">//千位上的数</span></span><br><span class="line">			<span class="type">int</span> B=i/<span class="number">100</span>%<span class="number">10</span>;                             <span class="comment">//百位上的数</span></span><br><span class="line">			<span class="type">int</span> C=i/<span class="number">10</span>%<span class="number">10</span>;                              <span class="comment">//十位上的数</span></span><br><span class="line">			<span class="keyword">if</span>(i%<span class="number">11</span>==<span class="number">0</span>&amp;&amp;A==B+C) &#123;                       <span class="comment">//如果是11的倍数，且十位数字加百位数字等于千位数字</span></span><br><span class="line">				pw.print(i+<span class="string">&quot;  &quot;</span>);                       <span class="comment">//打印输出该四位数</span></span><br><span class="line">				<span class="keyword">if</span>(++num==<span class="number">10</span>) &#123;                         <span class="comment">//每十个数换一行</span></span><br><span class="line">					num=<span class="number">0</span>;</span><br><span class="line">					pw.println();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fw.close();                                     <span class="comment">//关闭文本文件</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Linux回顾"><a href="#Linux回顾" class="headerlink" title="Linux回顾"></a>Linux回顾</h1><hr>
<h2 id="查找可执行文件的指令"><a href="#查找可执行文件的指令" class="headerlink" title="查找可执行文件的指令"></a>查找可执行文件的指令</h2><h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><ul>
<li>用于定位指令的二进制程序,源代码文件和man手册页等相关文件的路径.</li>
<li>whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（-b),man说明文件（-m），源代码文件（-s）</li>
</ul>
<h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><ul>
<li>locate和slocate命令都是用于查找文件或目录</li>
<li>locate其实是find -name的另一种写法，但是比后者搜索快，（原因locate不搜索具体目录）</li>
<li>注意：在使用前，使用updatedb命令，手动更新Linux数据库，在使用locate指令</li>
</ul>
<h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><ul>
<li>which命令用于查找并显示给定命令的绝对路径</li>
<li>环境变量PATH中保存查找命令的目录，which指令会在其寻找相应的符合条件的文件。</li>
</ul>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><ul>
<li><p>type命令用来显示指定命令的类型，判断给出的指令是内部还是外部指令。</p>
</li>
<li><p>命令类型：alias：别名；keyword、function、builtin：关键字，，函数，内建命令，Shell函数保留字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-t：输出“file”、“alias”或者“builtin”，分别表示给定的指令为“外部指令”、“命令别名”或者“内部指令”；</span><br><span class="line">-p：如果给出的指令为外部指令，则显示其绝对路径；</span><br><span class="line">-a：在环境变量“PATH”指定的路径中，显示给定指令的信息，包括命令别名。</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# type date date is /bin/date [root@localhost ~]# type mysql mysql is /usr/bin/mysql</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><ul>
<li>find命令用来在指定目录下寻找文件</li>
<li>如果使用该命令时,不设置任何参数,则find命令会在当前目录下查找子目录与文件.。</li>
</ul>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><hr>
<h2 id="多线程–守护线程和非守护线程"><a href="#多线程–守护线程和非守护线程" class="headerlink" title="多线程–守护线程和非守护线程"></a>多线程–守护线程和非守护线程</h2><h4 id="守护线程："><a href="#守护线程：" class="headerlink" title="守护线程："></a>守护线程：</h4><ul>
<li>和<strong>main</strong>相关的，用户线程，用户自己创建的线程，如果主线程停止，不会影响用户线程。</li>
<li><strong>GC线程</strong>（线程不定时回收垃圾）</li>
<li>特征：和主线程一起销毁。</li>
</ul>
<h4 id="非守护线程："><a href="#非守护线程：" class="headerlink" title="非守护线程："></a>非守护线程：</h4><ul>
<li>其实就是<strong>用户线程</strong></li>
<li>特征：和主线程互不影响。</li>
</ul>
<blockquote>
<p>其实：当所有的非守护线程结束时，程序就终止了，同时也会终止<strong>进程中</strong>所有的守护线程。</p>
</blockquote>
<p>如下图：<img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTc3ODM4,size_16,color_FFFFFF,t_70.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XUg5lPDg-1587784231713)(C:\Users\闫晓龙\AppData\Roaming\Typora\typora-user-images\image-20200425110023694.png)]"></p>
<h4 id="实例代码："><a href="#实例代码：" class="headerlink" title="实例代码："></a>实例代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">thread.setDaemon(<span class="literal">true</span>);  <span class="comment">//设置为守护线程</span></span><br><span class="line"></span><br><span class="line">代码如下 ：</span><br><span class="line"><span class="keyword">package</span> com.briup.demo.ThreadTest;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">		Threadthread <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span>&#123;</span><br><span class="line">						Thread.sleep(millis:<span class="number">100</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">					System.out.println(<span class="string">&quot;我是子线程.·.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		thread.setDaemon (<span class="literal">true</span>);  <span class="comment">//设置为守护线程</span></span><br><span class="line">		thread.start();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;我是主线程&quot;</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;主线程执行完毕！&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul>
<li>setDaemon（true）必须要在调用线程的start（）方法之前设置，否则会抛出异常。</li>
<li>在守护线程中产生的新线程也是守护线程。</li>
<li>不是所有的应用都可以分配守护线程，比如：读写操作或者计算机逻辑。</li>
</ul>
<h4 id="自定义守护线程"><a href="#自定义守护线程" class="headerlink" title="自定义守护线程"></a>自定义守护线程</h4><p>当然除去JVM内部的守护线程外，用户可以自定义：</p>
<ul>
<li><pre><code class="Java">//自定义:
public final void setDaemon(boolean on)

//可以通过方法查询该线程是否为守护线程
public final boolean isDaemon()

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># MyBatis常见问题</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 针对于mybatis缓存</span><br><span class="line"></span><br><span class="line">### 缓存理解</span><br><span class="line"></span><br><span class="line">&gt; 缓存的概念：存在内存中的临时资源。</span><br><span class="line"></span><br><span class="line">- 将用户经常查询的数据存放在内存中，当用户去查询数据的时候就不用去磁盘（关系型数据库文件）查；从而可以从缓存中查询，提高查询效率。</span><br><span class="line"></span><br><span class="line">&gt; 为什么使用缓存？</span><br><span class="line"></span><br><span class="line">- 减少和数据库的连接交互，减少系统开销，提高系统效率。</span><br><span class="line"></span><br><span class="line">&gt; 缓存适合什么样的数据？</span><br><span class="line"></span><br><span class="line">- 经常查询的，而且很少改变的数据。</span><br><span class="line"></span><br><span class="line">&gt; 缓存原理</span><br><span class="line"></span><br><span class="line">![img](../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/2053539-20201029112923376-360860914.png)</span><br><span class="line"></span><br><span class="line">### **MyBatis系统中默认定义两种缓存：**</span><br><span class="line"></span><br><span class="line">#### 一级缓存：</span><br><span class="line"></span><br><span class="line">- 默认开启，（SqlSession级别：称为本地缓存）</span><br><span class="line"></span><br><span class="line">#### 二级缓存（全局缓存）：</span><br><span class="line"></span><br><span class="line">- 需要手动设置，基于namespace 命名空间级别</span><br><span class="line"></span><br><span class="line">- 设置全局缓存：![img](../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/2053539-20201029105134449-1597163409.png)</span><br><span class="line"></span><br><span class="line">- ```xml</span><br><span class="line">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">  &lt;!DOCTYPE mapper</span><br><span class="line">          PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">          &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">  &lt;mapper namespace=&quot;com.king.dao.UserMapper&quot;&gt;</span><br><span class="line">      &lt;!--在当前Mapper.xml中使用二级缓存--&gt;</span><br><span class="line">      &lt;cache  eviction=&quot;FIFO&quot;</span><br><span class="line">              flushInterval=&quot;60000&quot;</span><br><span class="line">              size=&quot;512&quot;</span><br><span class="line">              readOnly=&quot;true&quot;/&gt;</span><br><span class="line">      &lt;select id=&quot;queryUserById&quot;  resultType=&quot;user&quot;&gt;</span><br><span class="line">          select * from mybatis.user WHERE id=#&#123;id&#125;</span><br><span class="line">      &lt;/select&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li><p>当然，也有自定义接口，通过实现Cache接口来实现</p>
</li>
</ul>
<blockquote>
<p>注意实体类的规范性</p>
</blockquote>
<h4 id="针对于实体类的缓存设置-需要该类实现序列化"><a href="#针对于实体类的缓存设置-需要该类实现序列化" class="headerlink" title="针对于实体类的缓存设置:需要该类实现序列化."></a>针对于实体类的缓存设置:需要该类实现序列化.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二级缓存的细节部分:</p>
<ol>
<li>只要开启了二级缓存，在同一个Mapper下就有效</li>
<li>所有的数据都会先放在一级缓存中；</li>
<li>只有当会话提交，或者关闭的时候，才会提交到二级缓冲中</li>
</ol>
</blockquote>
<h2 id="在Mybatis中乐观锁和悲观锁是什么，如何应用？"><a href="#在Mybatis中乐观锁和悲观锁是什么，如何应用？" class="headerlink" title="在Mybatis中乐观锁和悲观锁是什么，如何应用？"></a>在Mybatis中乐观锁和悲观锁是什么，如何应用？</h2><blockquote>
<p>什么是乐观锁？</p>
</blockquote>
<p><strong>乐观锁总是假设最好的情况，</strong>认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只有在提交修改的时候去验证对应资源（也就是数据）是否被其他线程修改了（具体方法可以使用版本号机制或者CAS算法处理）。</p>
<blockquote>
<p>什么是悲观锁？</p>
</blockquote>
<p><strong>悲观锁总是假设最坏的情况，</strong>认为共享资源每次被访问的时候就会出现问题（比如共享数据被修改），所以每次获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程。</strong></p>
<blockquote>
<p><strong>二者在处理高并发的情况下，又有什么差异？</strong></p>
</blockquote>
<ul>
<li>悲观锁：<ul>
<li>锁竞争激烈可能胡线程阻塞，增加系统开销，并且还可能存在死锁问题。</li>
<li>（理论上多用与写比较多的场景）<strong>多写场景，竞争激烈</strong></li>
<li><strong>开销固定</strong></li>
</ul>
</li>
<li>乐观锁：<ul>
<li>相对于悲观锁来说，不存在线程阻塞和死锁问题；但如果冲突频繁（写多的时候）会频繁失败和重试。</li>
<li>（多用于写比较少的场景）多读场景，竞争较少</li>
<li><strong>针对的对象是单个共享变量</strong></li>
</ul>
</li>
</ul>
<h2 id="什么是数据持久化？"><a href="#什么是数据持久化？" class="headerlink" title="什么是数据持久化？"></a>什么是数据持久化？</h2><p>数据持久化是将内存中的数据模型转换为存储模型，以及将存储模型转换为内存的数据模型的统称。</p>
<p>例如：<strong>文件的存储、数据的读取</strong>就是数据持久化操作。</p>
<p>我们编写应用程序操作数据库，<strong>对表数据进行增删改查</strong>的操作的时候就是数据持久化的操作。</p>
<h2 id="MyBatis框架简介"><a href="#MyBatis框架简介" class="headerlink" title="MyBatis框架简介"></a><strong>MyBatis框架简介</strong></h2><ul>
<li>MyBatis框架是一个<strong>开源的数据持久层</strong>框架</li>
<li>MyBatis的<strong>内部封装JDBC访问数据库</strong>的操作，可以支持普通的SQL查询、存储过程和高级映射。</li>
<li>MyBatis作为持久层框架，主要的思想：将程序中的大量SQL语句剥离出来，实现<strong>SQL的灵活配置</strong>。</li>
<li>好处：将SQL与程序代码分离。</li>
</ul>
<h2 id="什么是ORM？"><a href="#什么是ORM？" class="headerlink" title="什么是ORM？"></a>什么是ORM？</h2><p>ORM是对象关系映射，是一种数据持久化技术。它在对象模型和关系数据库直接建立起对应关系，</p>
<p>（实际：通过JavaBean对象去操作数据库表的数据）。</p>
<p>MyBatis通过<strong>简单的XML或注解的方式</strong>进行配置和原始映射，是一种<strong>半自动的ORM</strong>实现</p>
<h2 id="MyBatis的优缺点和使用场景"><a href="#MyBatis的优缺点和使用场景" class="headerlink" title="MyBatis的优缺点和使用场景"></a>MyBatis的优缺点和使用场景</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>减少JDBC的代码量、简单易学的框架</li>
<li>提交XML标签，支持编写<strong>动态的SQL</strong>，可以满足不同的业务需求</li>
<li>提供映射标签，支持<strong>对象与数据库的ORM字段关系映射</strong>。</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>SQL语句的编写工作量比较大，对开发人员编写SQL语句有一定的要求</li>
<li>SQL语句依赖于数据库，导致数据库<strong>不具有好的移植性</strong>，不可以随便更换数据库。</li>
</ul>
<h3 id="适合场景："><a href="#适合场景：" class="headerlink" title="适合场景："></a>适合场景：</h3><ul>
<li>MyBatis专注于SQL自身，是一个足够灵活的DAO层解决方案。<strong>解决对性能的要求很高</strong>。</li>
</ul>
<h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><ul>
<li><strong>#{}是预编译处理</strong>，${}是字符串替换。</li>
<li>MyBatis在处理#{}时，<strong>会将SQL中的#{}替换为“？”号</strong>，调用PrepareStatement的set方法来赋值。</li>
<li>MyBatis在处理${}时，替换成变量的值</li>
<li><strong>使用#{}可以有效防止SQL注入，提高系统安全性。</strong></li>
</ul>
<h2 id="当实体类中的属性名和表中的字段名不一样，怎么处理呢？"><a href="#当实体类中的属性名和表中的字段名不一样，怎么处理呢？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样，怎么处理呢？"></a>当实体类中的属性名和表中的字段名不一样，怎么处理呢？</h2><ul>
<li>第一种处理方式：通过在查询的SQL语句中定义字段名的别名，让<strong>字段名的别名和实体类的属性名</strong>一致</li>
<li>第二种处理方式：<strong>通过&#96;&#96;映射</strong>字段名和实体类属性名的一一对应的关系。</li>
</ul>
<h1 id="SpringBoot常见问题："><a href="#SpringBoot常见问题：" class="headerlink" title="SpringBoot常见问题："></a>SpringBoot常见问题：</h1><hr>
<h2 id="1、请简述-RequestBody-RequestParam-PathVariable三者区别"><a href="#1、请简述-RequestBody-RequestParam-PathVariable三者区别" class="headerlink" title="1、请简述@RequestBody @RequestParam @PathVariable三者区别"></a>1、请简述@RequestBody @RequestParam @PathVariable三者区别</h2><p>分别介绍：</p>
<ul>
<li>@RequestBody ：用于获取<strong>请求参数中</strong>的数据<ul>
<li>通常用于<strong>处理POST或者PUT请求</strong></li>
<li>解析请求体中的数据为JSON或者xml</li>
<li><strong>适用于处理复杂数据结构，将数据映射到对象或者集合中</strong></li>
</ul>
</li>
<li>@RequestParam  ：用于获取<strong>请求体中</strong>的参数<ul>
<li>用于处理GET和POST请求的表单数据</li>
<li>获取请求路径URL中的<strong>查询参数</strong>或者POST请求的表单参数</li>
<li><strong>适用于简单请求参数</strong></li>
</ul>
</li>
<li>@PathVariable ：用于获取<strong>请求路径中</strong>的参数<ul>
<li>通常处理RESTful风格的请求</li>
<li>可以将URL中的占位符提取为方法参数，<strong>标识资源</strong></li>
<li><strong>适用于获取URL中的动态参数</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>根据不同的业务需求选择使用注解</p>
</blockquote>
<h2 id="2、SpringMVC底层原理是什么"><a href="#2、SpringMVC底层原理是什么" class="headerlink" title="2、SpringMVC底层原理是什么"></a>2、SpringMVC底层原理是什么</h2><p><strong>首先交互流程：</strong></p>
<blockquote>
<p>当一个请求进来之前，SpringMVC中的核心组件会一起配合完成本次请求的处理：</p>
</blockquote>
<ul>
<li>请求被<strong>前端控制器（DispatcherServlet）</strong>接收到</li>
<li>前端控制器根据<strong>映射器</strong>中的配置（mapper.xml）的映射关系，将这个请求转交给<strong>真正能够处理客户端请求</strong>的处理器（Controller)</li>
<li>处理器（Controller）通过<strong>适配器</strong>，执行指定方法进行处理，完成后返回给<strong>用户ModelAndView</strong></li>
<li><strong>视图解析器</strong>（viewResolver）根据ModelAndView中的逻辑视图找到<strong>真正的物理视图</strong></li>
<li>使用ModelAndView中的模型对视图进行<strong>渲染</strong></li>
</ul>
<p>下列图是对上述流程的图像描述：</p>
<blockquote>
<p>以下三张图都是描述Spring MVC如何处理一个请求？</p>
</blockquote>
<ul>
<li><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/image-20231023171105674.png" alt="image-20231023171105674"></li>
<li><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/image-20231023171118007.png" alt="image-20231023171118007"></li>
<li><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/image-20231023171136050.png" alt="image-20231023171136050"></li>
</ul>
<hr>
<h1 id="HashMap常见问题"><a href="#HashMap常见问题" class="headerlink" title="HashMap常见问题"></a>HashMap常见问题</h1><hr>
<h4 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h4><ul>
<li><strong>Hash表结构</strong>（链表散列：<strong>数组+链表</strong>）实现，结合数组和链表的优点。<strong>当链表长度超过8时，链表转为红黑树</strong>。</li>
</ul>
<h4 id="2、HashMap的工作原理"><a href="#2、HashMap的工作原理" class="headerlink" title="2、HashMap的工作原理"></a>2、HashMap的工作原理</h4><ul>
<li><p>底层是Hash数组和单向链表，数组中每个元素是链表。</p>
</li>
<li><p>由Node内部类（实现Map.Entry&lt;K,V&gt;接口）实现。</p>
</li>
<li><p>HashMap运用：</p>
<ul>
<li><p>put方法：存储对象时 ，将kv键值对传给put方法。</p>
<ul>
<li>针对于JDK1.7之前使用头插法、JDK1.8使用尾插法（链表）</li>
</ul>
<blockquote>
<p>注意：当碰撞导致链表长度大于8时，链表转换为红黑树。</p>
</blockquote>
<ul>
<li>实现细节：<ul>
<li>1、利用Hash计算Hash值，2、调整数组大小（扩容之类）</li>
<li>步骤3：<ul>
<li>如果k的<strong>Hash值</strong>在HashMap中不存在，插入值；<strong>存在，碰撞</strong></li>
<li>如果存在，且两者的**.equals方法<strong>返回值true，</strong>更新键值**</li>
<li>如果存在，但是返回值为false，则插入<strong>链表尾部</strong>或者<strong>红黑树中</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>get方法：获取对象时，将K传给get方法。</p>
<ul>
<li><strong>hashcode</strong>是定位的，<strong>存储位置</strong>；</li>
<li>equals方法是定性的，比较两者是否相等。</li>
<li>实现：<ul>
<li>调用Hash计算Hash值，获取该键值所在的<strong>链表的数组下标</strong></li>
<li>顺序遍历链表，equals方法查找Node链表中<strong>K所对应的V</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3、当两个对象的hashcode相同会发生什么？"><a href="#3、当两个对象的hashcode相同会发生什么？" class="headerlink" title="3、当两个对象的hashcode相同会发生什么？"></a>3、当两个对象的hashcode相同会发生什么？</h4><ul>
<li>因为hashcode相同，不一定就是相等（equals方法比较值）；这时两个对象的<strong>数组下标一样</strong>，此时会发生”<strong>碰撞</strong>“。</li>
<li>因为HashMap使用链表存储对象，这个Node会存储到链表中。</li>
</ul>
<h4 id="4、你知道Hash的实现吗？为什么要这么实现呢？"><a href="#4、你知道Hash的实现吗？为什么要这么实现呢？" class="headerlink" title="4、你知道Hash的实现吗？为什么要这么实现呢？"></a>4、你知道Hash的实现吗？为什么要这么实现呢？</h4><ul>
<li>在JDK1.8中，通过hashcode的<strong>高16位异或低16位</strong>实现的；</li>
<li>主要从速度、功效和质量来考虑：<strong>减少系统的开销</strong>，也不会造成因为高位木参与下标的计算从而发生“碰撞”</li>
</ul>
<h4 id="5、为什么要用异或运算符？"><a href="#5、为什么要用异或运算符？" class="headerlink" title="5、为什么要用异或运算符？"></a>5、为什么要用异或运算符？</h4><ul>
<li><strong>保证了对象的hashcode的32位值</strong>，只要有一位发生改变，整个Hash（）方法返回值也改变，<strong>尽可能减少碰撞</strong></li>
</ul>
<h4 id="6、HashMap的table的容量如何确定？"><a href="#6、HashMap的table的容量如何确定？" class="headerlink" title="6、HashMap的table的容量如何确定？"></a>6、HashMap的table的容量如何确定？</h4><ul>
<li>table数组大小：由capacity参数决定，默认是16，也可以构造时传入，最大限制1&lt;&lt;30;</li>
</ul>
<h4 id="7、loadFactor是什么？该容量如何变化？这个变化会带来什么问题？"><a href="#7、loadFactor是什么？该容量如何变化？这个变化会带来什么问题？" class="headerlink" title="7、loadFactor是什么？该容量如何变化？这个变化会带来什么问题？"></a>7、loadFactor是什么？该容量如何变化？这个变化会带来什么问题？</h4><h5 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h5><ul>
<li><strong>loadFactor：装载因子</strong>，</li>
<li>作用：确定table数组是否动态扩容，<strong>默认值0.75，</strong></li>
<li>例子：当table数组为16，loadFactor为0.75时，<strong>threshold就是12</strong>，当超过12时，<strong>数组动态扩容。</strong></li>
</ul>
<h5 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h5><ul>
<li>扩容时，调用<strong>resize（）方法</strong>，将table长度变为原来的两倍</li>
</ul>
<h5 id="问题三："><a href="#问题三：" class="headerlink" title="问题三："></a>问题三：</h5><ul>
<li>当数据量很大时，扩展会带来<strong>性能的损失</strong>。</li>
</ul>
<h4 id="8、说说你对红黑树的见解？"><a href="#8、说说你对红黑树的见解？" class="headerlink" title="8、说说你对红黑树的见解？"></a>8、说说你对红黑树的见解？</h4><ul>
<li>每个节点非红即黑</li>
<li>根节点总是黑色的</li>
<li>如果节点是红色的，则它的子节点必须是黑色的</li>
<li>每一个叶子节点都是黑色的空节点</li>
<li>从根节点到叶子结点或者空子节点的每条路径，必须包含相同数目的黑色节点（相同的黑色高度）</li>
</ul>
<h4 id="9、HashMap、linkedHashMap、treeMap的区别？"><a href="#9、HashMap、linkedHashMap、treeMap的区别？" class="headerlink" title="9、HashMap、linkedHashMap、treeMap的区别？"></a>9、HashMap、linkedHashMap、treeMap的区别？</h4><ul>
<li>linkedHashMap：保存记录插入的位置，用Iterator遍历时，先取到的记录肯定是先插入的，遍历比HashMap慢。</li>
<li>treeMap：实现SortMap接口，能够把它保存的记录根据键排序（默认升序）</li>
</ul>
<h4 id="10、HashMap、linkedHashMap、treeMap使用场景？"><a href="#10、HashMap、linkedHashMap、treeMap使用场景？" class="headerlink" title="10、HashMap、linkedHashMap、treeMap使用场景？"></a>10、HashMap、linkedHashMap、treeMap使用场景？</h4><blockquote>
<p>一般情况下，HashMap用最多</p>
</blockquote>
<ul>
<li>HashMap：在Map中插入、删除、和定位元素时</li>
<li>linkedHashMap：当输入顺序和输出顺序一致的情况下</li>
<li>treeMap：需要按自然顺序或自定义顺序遍历键的情况</li>
</ul>
<h4 id="11、区别：HashMap—HashTable"><a href="#11、区别：HashMap—HashTable" class="headerlink" title="11、区别：HashMap—HashTable"></a>11、区别：HashMap—HashTable</h4><ul>
<li><strong>线程安全：</strong>HashTable；线程不安全：HashMap</li>
<li><strong>效率：</strong>HashTable&lt;HashMap</li>
<li><strong>键值对：</strong>HashMap最多只允许一个键&#x3D;null，多个值&#x3D;null；HashTable不允许；</li>
<li><strong>初始化和扩容：</strong>HashMap初始化数组为16，<strong>HashTable为11</strong><ul>
<li>扩容时：前者扩大两倍，后者扩大三倍</li>
</ul>
</li>
<li>HashMap每次重新计算Hash值；HashTable直接使用对象hashcode</li>
</ul>
<h4 id="12、HashMap的不安全体现在哪里？"><a href="#12、HashMap的不安全体现在哪里？" class="headerlink" title="12、HashMap的不安全体现在哪里？"></a>12、HashMap的不安全体现在哪里？</h4><p><strong>主要体现：</strong></p>
<ul>
<li>在JDK1.7中，多线程环境下，扩容时会造成<strong>环形链</strong>或者<strong>数据丢失</strong></li>
<li>JDK1.8中，多线程环境下，会发生<strong>数据覆盖</strong>的情况</li>
</ul>
<h4 id="13、HashMap怎样解决Hash冲突？"><a href="#13、HashMap怎样解决Hash冲突？" class="headerlink" title="13、HashMap怎样解决Hash冲突？"></a>13、HashMap怎样解决Hash冲突？</h4><ul>
<li>使用<strong>链地址法（散列表）</strong>来连接拥有相同Hash值的数据</li>
<li>使用2次扰动函数（<strong>Hash函数</strong>）来降低哈希冲突的概率，使得<strong>数据分布更平均</strong></li>
<li>引入<strong>红黑树</strong>进一步<strong>降低</strong>遍历的<strong>时间复杂度</strong>。</li>
</ul>
<h4 id="14、HashMap和ConcurrentHashMap的区别？"><a href="#14、HashMap和ConcurrentHashMap的区别？" class="headerlink" title="14、HashMap和ConcurrentHashMap的区别？"></a>14、HashMap和ConcurrentHashMap的区别？</h4><ul>
<li>后者是<strong>加锁</strong>的</li>
<li>HashMap的键值对允许有null，后者是<strong>kv都不能为null。</strong></li>
</ul>
<h1 id="Java基础常见面试回顾"><a href="#Java基础常见面试回顾" class="headerlink" title="Java基础常见面试回顾"></a>Java基础常见面试回顾</h1><hr>
<h2 id="Java常见面试题（上）"><a href="#Java常见面试题（上）" class="headerlink" title="Java常见面试题（上）"></a>Java常见面试题（上）</h2><h3 id="基础概念和常识"><a href="#基础概念和常识" class="headerlink" title="基础概念和常识"></a>基础概念和常识</h3><h4 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h4><ul>
<li><p>简单易学；<strong>面向对象（封装、继承、多态）</strong>；跨平台；</p>
</li>
<li><p>支持多线程；可靠性（具备异常处理和<strong>自动内存回收</strong>）；</p>
</li>
<li><p>安全性（提供多种安全防护机制，如访问权限修饰符等）；</p>
</li>
<li><p>高效性（just in time编译器优化处理）；</p>
</li>
<li><p>支持网络编程；<strong>编译和解释并存</strong>；</p>
</li>
</ul>
<h4 id="Java-SE-vs-Java-EE"><a href="#Java-SE-vs-Java-EE" class="headerlink" title="Java SE vs Java EE"></a>Java SE vs Java EE</h4><ul>
<li>Java SE是Java的<strong>基础版本</strong>，适合开发<strong>桌面应用程序</strong>||简单的服务器应用程序；</li>
<li><strong>Java EE</strong>是Java的高级版本，适合开发复杂的企业级应用程序||<strong>Web应用程序</strong>。</li>
</ul>
<h4 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h4><ul>
<li>JVM<ul>
<li>是运行<strong>Java字节码</strong>的虚拟机。</li>
<li>“一次编译，到处运行”关键：字节码文件和不同系统的JVM实现。</li>
</ul>
</li>
<li>JRE<ul>
<li>是Java运行时环境，包含有<strong>JVM、Java基础类库（class library）</strong></li>
</ul>
</li>
<li>JDK<ul>
<li>包含JRE、同时也含有javac、javadoc等工具，</li>
<li>用于 Java应用程序的开发和调试。</li>
</ul>
</li>
</ul>
<h4 id="什么是字节码？采用它的好处是什么？"><a href="#什么是字节码？采用它的好处是什么？" class="headerlink" title="什么是字节码？采用它的好处是什么？"></a>什么是字节码？采用它的好处是什么？</h4><ul>
<li><p>字节码</p>
<ul>
<li>在Java中，JVM可以理解的代码就是字节码文件（.class文件），</li>
<li>它不面向任何特定处理器，<strong>只面向虚拟机。</strong></li>
<li><strong>在一定程度上解决传统语言执行效率低，也保留解释性语言的可移植的特点。</strong></li>
</ul>
<p>字节码处理的视图：</p>
<p>​	<img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/java-code-to-machine-code-with-jit.png" alt="Java程序转变为机器代码的过程"></p>
<blockquote>
<p><strong>HOtSpot采用惰性评估</strong>；根据<strong>二八定律</strong>，消耗大部分系统资源的只有一小部分代码（<strong>热点代码</strong>），JIT所编译就是这部分。JVM会根据代码每次执行的情况做出优化。</p>
</blockquote>
</li>
<li><p>下面是JDK、JRE、JVM、JIT的结构：</p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/jdk-jre-jvm-jit.png" alt="JDK、JRE、JVM、JIT 这四者的关系"></p>
</li>
</ul>
<h4 id="为什么说Java语言“编译与解释并存”？"><a href="#为什么说Java语言“编译与解释并存”？" class="headerlink" title="为什么说Java语言“编译与解释并存”？"></a>为什么说Java语言“编译与解释并存”？</h4><ul>
<li>高级编程语言<ul>
<li>编译型<ul>
<li>通过编译器一次性翻译成机器码</li>
<li><strong>特点：执行速度快，开发效率低</strong></li>
</ul>
</li>
<li>解释型<ul>
<li>通过解释器一句一句的将代码解释为机器码</li>
<li>特点：<strong>执行速度慢，开发效率高</strong></li>
</ul>
</li>
</ul>
</li>
<li>步骤过程：由Java编写的程序先经过编译-》字节码文件（.class）-》Java解释器执行</li>
</ul>
<h4 id="AOT有什么优点？为什么不全部使用AOT呢？"><a href="#AOT有什么优点？为什么不全部使用AOT呢？" class="headerlink" title="AOT有什么优点？为什么不全部使用AOT呢？"></a>AOT有什么优点？为什么不全部使用AOT呢？</h4><ul>
<li>AOT：<ul>
<li>是JDK9中新的编译模式AOT，</li>
<li>和JIT的区别在于：Java程序被<strong>执行前</strong>就将其编译成机器码，属于<strong>静态编译</strong>（C、C++、GO等）</li>
<li>主要优势在于：启动时间短、内存占用少、增强Java的程序安全性。</li>
<li>使用场景：云原生</li>
</ul>
</li>
<li>原因：<ul>
<li>AOT编译器不支持Java的一些动态特性（如<strong>反射、动态代理、动态加载、JNI</strong>《Java Native Interface》）</li>
<li>根据这些特性，一些框架和库也不能用（<strong>Spring 、CGLIB</strong>）</li>
<li>所以选择使用<strong>JIT即时编译器</strong></li>
</ul>
</li>
</ul>
<h4 id="Oracle-JDK-vs-Open-JDK"><a href="#Oracle-JDK-vs-Open-JDK" class="headerlink" title="Oracle JDK vs Open JDK"></a>Oracle JDK vs Open JDK</h4><ul>
<li>区别<ul>
<li><strong>是否开源：</strong>Open JDK完全开源；Oracle JDK是基于Open JDK实现的，不完全开源。</li>
<li><strong>是否免费：</strong>Oracle JDK有免费版本，但是有时间限制；Open JDK完全free</li>
<li><strong>功能性：</strong>Oracle JDK在Open JDK基础添加新功能：JFR、JMC等</li>
<li><strong>稳定性：</strong>Open JDK不提供LTS服务，Oracle JDK每三年提供一次</li>
<li><strong>协议：</strong>Oracle JDK使用BCL&#x2F;OTN协议，而Open JDK使用GPL v2许可</li>
</ul>
</li>
</ul>
<h4 id="Java和C-的区别？"><a href="#Java和C-的区别？" class="headerlink" title="&#x3D;&#x3D;Java和C++的区别？&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java和C++的区别？&#x3D;&#x3D;</h4><ul>
<li><blockquote>
<p>Java和C++都是面向对象（封装、继承、多态）</p>
</blockquote>
</li>
<li><p>区别</p>
<ul>
<li>Java<strong>不提供指针</strong>来直接访问内存，程序<strong>内存更加安全</strong></li>
<li>Java的类是单继承，<strong>C++支持多继承</strong>；但是Java的接口可以多继承。</li>
<li>Java有自动内存管理垃圾回收机制（<strong>GC</strong>），不用手动释放内存</li>
<li><strong>C++同时支持方法重载和操作符重载</strong>；Java只支持方法重载（设计思想不同）</li>
</ul>
</li>
</ul>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/image-20231010152847331.png" alt="image-20231010152847331"></p>
<h2 id="Java常见面试题（中）"><a href="#Java常见面试题（中）" class="headerlink" title="Java常见面试题（中）"></a>Java常见面试题（中）</h2><h2 id="Java常见面试题（下）"><a href="#Java常见面试题（下）" class="headerlink" title="Java常见面试题（下）"></a>Java常见面试题（下）</h2><p>线程池：</p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/image-20231116102824024.png" alt="image-20231116102824024"></p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/image-20231116102830776.png" alt="image-20231116102830776"></p>
<h1 id="掌上刷题宝"><a href="#掌上刷题宝" class="headerlink" title="掌上刷题宝"></a>掌上刷题宝</h1><h2 id="Java变量"><a href="#Java变量" class="headerlink" title="Java变量"></a>Java变量</h2><blockquote>
<p>解释什么是类的成员变量，局部变量，实例成员变量，类成员变量？</p>
</blockquote>
<p>首先，</p>
<ul>
<li>类的成员变量：变量定义部分所定义的变量；</li>
<li>局部变量：在方法体中定义的变量和方法参数</li>
<li><strong>成员变量：实例成员变量和类成员变量（static修饰）</strong></li>
</ul>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><blockquote>
<p>简述this关键字用法。</p>
</blockquote>
<p><strong>this关键字</strong>使用在实例方法中，指针变量，代表（指向）调用<strong>该方法的当前对象</strong>。</p>
<h2 id="Java返回值"><a href="#Java返回值" class="headerlink" title="Java返回值"></a>Java返回值</h2><blockquote>
<p>如何确定方法的返回类型？</p>
</blockquote>
<p>方法的返回类型：<strong>方法返回的值的类型</strong>；如果无返回值，则返回类型为void。</p>
<blockquote>
<p>返回值为void的方法，可否有return？</p>
</blockquote>
<p><strong>可以</strong>，但是return后没有任何值信息。</p>
<h2 id="Java命名"><a href="#Java命名" class="headerlink" title="Java命名"></a>Java命名</h2><blockquote>
<p>简述方法和变量的命名规则？</p>
</blockquote>
<p><strong>首写字母使用小写</strong>，如果由多个单词组成，从第二个单词开始首字母使用大写。</p>
<h2 id="Java含义"><a href="#Java含义" class="headerlink" title="Java含义"></a>Java含义</h2><blockquote>
<p>什么是Java？</p>
</blockquote>
<p>Java是一门面向对象编程语言，不仅吸收了c++语言优点，<strong>Java语言具有功能强大和简单易用大特征</strong>，Java语言作为<strong>静态面向对象</strong>编程语言的代表。</p>
<h2 id="JVM含义"><a href="#JVM含义" class="headerlink" title="JVM含义"></a>JVM含义</h2><blockquote>
<p>JVM是什么？</p>
</blockquote>
<p><strong>JVM是Java虚拟机</strong>，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现<strong>跨平台</strong>。</p>
<h2 id="JRE含义"><a href="#JRE含义" class="headerlink" title="JRE含义"></a>JRE含义</h2><blockquote>
<p>JRE是什么？</p>
</blockquote>
<p>Java Runtime Environment包括 <strong>Java虚拟机</strong>和<strong>Java程序所需的核心类库</strong>等，</p>
<p><strong>核心类库主要是Java.lang包</strong>：包含运行Java程序必不可少的系统类，例如：基本数据类型、基本数学函数、字符串处理、线程、异常处理类。</p>
<p>总的来说：想要运行一个开发好的Java程序，只<strong>需要安装JRE即可</strong>。</p>
<h2 id="JDK含义"><a href="#JDK含义" class="headerlink" title="JDK含义"></a>JDK含义</h2><blockquote>
<p>JDK是什么？</p>
</blockquote>
<p>Java Development Kit是提供给Java开发人员使用的，其中包含Java的开发工具，也包括JRE。JDK中包含开发工具：编译工具（<strong>javac.exe</strong>）和打包工具（<strong>jar.exe</strong>）</p>
<h2 id="Java语言特点-1"><a href="#Java语言特点-1" class="headerlink" title="Java语言特点"></a>Java语言特点</h2><blockquote>
<p>Java语言有哪些特点？</p>
</blockquote>
<p>特点包含以下：</p>
<ul>
<li>简单易学</li>
<li>面向对象（封装，继承，多态）</li>
<li>平台无关性（Java虚拟机实现平台无关性）</li>
<li>支持网络编程</li>
<li>支持多线程</li>
<li>健壮性（比如：强类型机制，异常处理，垃圾自动回收）</li>
<li>安全性</li>
</ul>
<h2 id="JDK1-8新特性"><a href="#JDK1-8新特性" class="headerlink" title="JDK1.8新特性"></a>JDK1.8新特性</h2><blockquote>
<p>Java 8的接口新增了那些特性？</p>
</blockquote>
<p>Lambda表达式、函数式接口、Stream API、方法引用、Optional、默认方法。</p>
<h2 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h2><blockquote>
<p>重写和重载的区别</p>
</blockquote>
<p>区别：</p>
<ul>
<li><strong>作用范围：</strong><ul>
<li>重写：是父类和子类之间</li>
<li>重载：同一个类中</li>
</ul>
</li>
<li><strong>参数列表：</strong><ul>
<li>重写：不能修改</li>
<li>重载：参数的顺序、个数、类型</li>
</ul>
</li>
<li><strong>返回类型：</strong><ul>
<li>重写：方法返回相同类型或子类</li>
<li>重载：可修改</li>
</ul>
</li>
<li><strong>抛出异常：</strong><ul>
<li>重写：可以减少或者删除，但是一定不能抛出新的或者比父类范围大的异常。</li>
<li>重载：可以修改</li>
</ul>
</li>
<li><strong>访问权限：</strong><ul>
<li>重写：不能比父类更小的访问权限</li>
<li>重载：可以修改</li>
</ul>
</li>
</ul>
<h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><blockquote>
<p>抽象类和接口有什么区别？</p>
</blockquote>
<p>区别：</p>
<ul>
<li>抽象类可以有普通变量，<code>接口中只能是公共的静态的常量</code>（public static final</li>
<li>一个类可以<strong>实现多个接口</strong>，<strong>但是只能继承一个父类</strong>，这个父类可以是抽象类</li>
<li>抽象级别（高到低）：接口&gt;抽象类&gt;实现类</li>
<li>抽象类的关键字：abstract；接口关键字：interface；</li>
<li><strong>抽象类和接口都不能够实例化、不能有构造方法</strong></li>
<li>接口里的方法只能是<strong>抽象方法、类方法或者默认方法</strong></li>
</ul>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><blockquote>
<p>Java中IO流分为几种？</p>
</blockquote>
<p>Java中的流分为两种：字节流和字符流</p>
<p>IO流分别四个抽象类表示：InputStream，OutputStream，Reader、Writer。</p>
<h2 id="多线程好处"><a href="#多线程好处" class="headerlink" title="多线程好处"></a>多线程好处</h2><blockquote>
<p>多线程有什么好处？</p>
</blockquote>
<p>好处在于：</p>
<ul>
<li><strong>更好的利用CPU</strong></li>
<li>简单的程序设计</li>
<li>程序更多的响应</li>
<li><strong>多任务下CPU资源分配公平性</strong></li>
</ul>
<h2 id="理解面向对象三个特征"><a href="#理解面向对象三个特征" class="headerlink" title="理解面向对象三个特征"></a>理解面向对象三个特征</h2><blockquote>
<p>面向对象的三个特征是什么？什么是封装、继承、多态？</p>
</blockquote>
<p>面向对象的三个基本特征：<strong>封装、继承、多态</strong>。</p>
<blockquote>
<p>什么是封装？</p>
</blockquote>
<ul>
<li>指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法</li>
<li><strong>简单理解：将接口实现过程包装隐藏起来,指向外界提供简单的编程接口</strong></li>
</ul>
<blockquote>
<p>什么是继承？</p>
</blockquote>
<ul>
<li>继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法</li>
<li><strong>简单理解：一个对象从另一个对象获取属性的过程</strong></li>
</ul>
<blockquote>
<p>什么是多态？</p>
</blockquote>
<ul>
<li>同一个行为具有多个不同表现形式或者形态的能力</li>
<li><strong>简单理解：多态就是对象多种表现形式的体现。</strong></li>
</ul>
<h2 id="Java数据结构：栈、堆"><a href="#Java数据结构：栈、堆" class="headerlink" title="Java数据结构：栈、堆"></a>Java数据结构：栈、堆</h2><blockquote>
<p>常用的数据结构？</p>
</blockquote>
<p><strong>集合、线性结构（数组、队列、链表、栈）</strong>、树形结构、图状结构</p>
<blockquote>
<p>Java中堆和栈有什么区别？</p>
</blockquote>
<p>堆和栈区别：</p>
<ul>
<li><p><strong>内存区域不同：</strong>JVM中堆和栈属于不同的内存区域。</p>
</li>
<li><p><strong>目的不同：</strong></p>
<ul>
<li>栈常用于保存<strong>方法帧</strong>和局部变量</li>
<li><strong>堆常用于保存对象</strong></li>
</ul>
</li>
<li><p><strong>空间大小不同</strong>：栈通常都比堆小</p>
</li>
<li><p><strong>线程共享：</strong></p>
<ul>
<li>栈不能被多线程共享</li>
<li>堆被整个JVM的所有线程共享。</li>
</ul>
</li>
</ul>
<h2 id="理解堆空间和GC垃圾回收"><a href="#理解堆空间和GC垃圾回收" class="headerlink" title="理解堆空间和GC垃圾回收"></a>理解堆空间和GC垃圾回收</h2><blockquote>
<p> 解释堆空间和GC是什么？</p>
</blockquote>
<p>Java进程进来时，会为它<strong>自动分配空间内存</strong>。</p>
<p>此时内存的一部分用于创建堆空间，当程序中<strong>创建对象的时候</strong>，就<strong>从堆空间中分配内存</strong>。</p>
<p><strong>GC是JVM内部的一个进程</strong>，<code>回收无效对象的内存</code>用于将来的分配</p>
<h2 id="理解泛型"><a href="#理解泛型" class="headerlink" title="理解泛型"></a>理解泛型</h2><blockquote>
<p>简述对泛型的理解。</p>
</blockquote>
<p>首先，在Java中，<code>泛型是一种在编译时期进行类型检查的机制</code>，它允许我们在定义类、接口、方法时使用类型参数，从而使得代码更加<strong>灵活和可重用</strong>。</p>
<p>有以下优点：</p>
<ul>
<li><strong>类型安全</strong>：通过编译器的类型检查，减少程序中类型错误。</li>
<li><strong>代码重用</strong>：可以编写一次代码，适用于多种数据类型。</li>
<li><strong>简化代码</strong>：使用可以避免手动进行类型转换，减少代码冗余。</li>
<li><strong>提高性能</strong>：避免运行时类型转换，提高性能</li>
<li><strong>增加代码可读性和维护性</strong></li>
</ul>
<h2 id="理解反射"><a href="#理解反射" class="headerlink" title="理解反射"></a>理解反射</h2><blockquote>
<p>什么是反射，如何使用反射？在什么使用场景？</p>
</blockquote>
<p><strong>反射：是指在运行时获取程序类的信息，并能操作类的属性、方法和构造器等。</strong></p>
<p>简单版：在Java中，<code>反射是提供一种动态地访问类的信息和方法的机制</code>，可以提高程序的灵活性和可扩展性。</p>
<p>使用反射：</p>
<ul>
<li><strong>获取类对象</strong>：利用<code>Class.forName()</code>方法</li>
<li><strong>获取类信息：</strong>使用<code>Class类提供的方法getClass</code>来获取类信息</li>
<li><strong>操作类成员</strong>：可以通过<code>.class</code>操作属性、方法、构造器。</li>
</ul>
<p>反射使用场景：</p>
<ul>
<li>在<code>运行时</code>处理：<ul>
<li>动态<strong>创建对象</strong></li>
<li>动态<strong>调用方法</strong></li>
<li><strong>获取类的信息</strong></li>
<li>进行类型转换</li>
</ul>
</li>
</ul>
<h2 id="String、StringBuffer、StringBuilder区别"><a href="#String、StringBuffer、StringBuilder区别" class="headerlink" title="String、StringBuffer、StringBuilder区别"></a>String、StringBuffer、StringBuilder区别</h2><blockquote>
<p>String 、StringBuffer、StringBuilder的区别？</p>
</blockquote>
<p><strong>String声明的对象是不可变的对象</strong>，每次操作都会生成新的对象，然后指向新的对象</p>
<p>为什么说是不可变的对象呢？从源码上来看被<code>final</code>修饰处理<img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/image-20231119150534402.png" alt="image-20231119150534402"></p>
<p><strong>StringBuffer</strong>是在对原有的对象上进行操作的，是<strong>线程安全</strong>的，适合<strong>多线程</strong>。</p>
<p><strong>StringBuilder</strong>是在对原有的对象上进行操作的，不是线程安全的，适合单线程。</p>
<p>对比之下： StringBuilder性能比StringBuffer更高</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><blockquote>
<p>什么是进程，什么是线程，如何创建线程？</p>
</blockquote>
<p><strong>进程</strong>：操作系统<strong>分配资源的最小单元</strong>，是系统中正在运行的一个程序，程序一旦运行就是进程。（如果想让一个进程访问另一个进程的资源，需要使用进程间通信，比如<strong>管道，文件</strong>，<strong>套接字</strong>）</p>
<p><strong>线程</strong>：是操作系统能够进行<strong>运算调度的最小单位</strong>。它被包含在进程之中，是进程中的<strong>实际运作单位</strong>。</p>
<p>对比之下：<code>一个程序至少有一个进程，一个进程至少有一个线程。</code></p>
<p>&#x3D;&#x3D;创建线程的方式&#x2F;流程&#x3D;&#x3D;：</p>
<ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable和Future Task</li>
<li>通过线程池（Thread pool）创建线程</li>
</ul>
<blockquote>
<p>线程的run（）和Start（）有什么区别？</p>
</blockquote>
<p><code>调用start（）方法</code>是用来启动线程的，轮到该线程执行时，会自动调用run（）方法。</p>
<p><code>直接调用run方法</code>是无法达到启动多线程的目的，相当于主线程执行Thread对象的run()方法。</p>
<p>一个线程对应的start（）方法只能调用一次，多次调用会抛出异常（java.lang.IllegalThreadStateException ); <code>run（）方法没有限制</code>。</p>
<blockquote>
<p>如何创建线程池？</p>
</blockquote>
<p>Java通过Executors （Java并发包）提供四种线程池：</p>
<ul>
<li><p>newCachedThreadPool：可缓存线程池</p>
</li>
<li><p>定长线程池：</p>
<ul>
<li>newFixedThreadPool：<strong>可控线程最大并发数</strong>，超出的线程在队列等待处理</li>
<li>newScheduledThreadPool：支持<strong>定时及周期性</strong>任务执行</li>
</ul>
</li>
<li><p>newSingleThreadExecutor：单线程化的线程池</p>
</li>
<li><p>Java8新添加</p>
<ul>
<li>newWorkStealingPool：会创建一个任务窃取线程池（采用先进先出<strong>FIFO</strong>），可以降低冲突，优化的解决方法。</li>
</ul>
</li>
<li></li>
</ul>
<h1 id="多益网络："><a href="#多益网络：" class="headerlink" title="多益网络："></a>多益网络：</h1><blockquote>
<p>Java的工厂模式</p>
</blockquote>
<p>工厂模式：是一种<strong>创建型设计模式</strong>，它使对象的创建与代码<strong>分离</strong>，从而使得代码更<strong>易于维护和扩展</strong>。</p>
<p>常见的三种实现方式：</p>
<ul>
<li><strong>简单工厂模式</strong>、<strong>将对象集中在一类中，再由这个类根据参数创建对象</strong>。</li>
<li><strong>工厂方法模式</strong>、将对象的创建给子类处理，再由子类根据自己的需要创建适合的对象。</li>
<li><strong>抽象工厂模式</strong>、将创建交给<strong>多个子类</strong>，再由子类来创建自己需要的对象。</li>
</ul>
<blockquote>
<p>.java的事务，如何确保一致性</p>
</blockquote>
<p>首先，确保一致性，我们可以使用一下的几种方法：</p>
<ul>
<li><p>使用<strong>数据库的四个特性</strong>：原子性、一致性、隔离性、持久性</p>
</li>
<li><p>可以使用<strong>事务管理器</strong></p>
</li>
<li><p>可以使用<strong>悲观锁或者乐观锁</strong>解决事务冲突，来保证事务的一致性</p>
<ul>
<li>悲观锁：不读脏数据，效率低</li>
</ul>
</li>
<li><p>乐观锁：效率高，容易读脏数据</p>
</li>
</ul>
<h2 id="自我介绍-1"><a href="#自我介绍-1" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>面试官您好，我是来自广西科技大学的大四应届毕业生，在校期间主修软件工程专业。在校期间还参加校级ACM比赛并获得优胜奖，还担任院级青年志愿者协会活动部部长一年半。以下是我的个人优势：熟悉并掌握java基础、MySQL、MyBatis。掌握了MyBatisPlus、Spring、SpringMVC和SPringBoot框架的使用。掌握Redis的基本使用，熟悉使用Maven进行项目管理、和git，svn的版本控制。了解Linux基本指令和docker的基本项目部署。</p>
<p>我在大学期间也曾做过模拟ai聊天程序和智慧农产品溯源项目，对于ai聊天是基于ChatGPTapi接口实现的交互式聊天程序，对于农产品溯源的项目采用前后端分离，实现后台农产品从生产到销售的信息溯源。以上就是我的自我介绍。</p>
<h2 id="智慧项目"><a href="#智慧项目" class="headerlink" title="智慧项目"></a>智慧项目</h2><h3 id="智慧项目的分工："><a href="#智慧项目的分工：" class="headerlink" title="智慧项目的分工："></a>智慧项目的分工：</h3><p>首先项目的一个背景：是在参加一个志愿者活动中遇到乡里的农产品因为信息源的不安全，导致出现大批量退货。我们几个小伙伴就想着一个搞一个农产品信息链。</p>
<p>我的职责：</p>
<p>后端设计：根据需求设计后端接口和数据库表结构的设计</p>
<p>开发：实现后端接口和数据相应操作，实现后端权限控制保证系统安全。</p>
<p>测试：测试后端接口和数据库操作，确保功能正常。</p>
<blockquote>
<p>问题的触发：？</p>
</blockquote>
<h3 id="讲一下二维码是如何追溯信息的"><a href="#讲一下二维码是如何追溯信息的" class="headerlink" title="讲一下二维码是如何追溯信息的."></a>讲一下二维码是如何追溯信息的.</h3><p>答：扫码的流程：</p>
<h4 id="产品信息录入和生成二维码：使用二维码生成库处理二维码和产品的信息关联。"><a href="#产品信息录入和生成二维码：使用二维码生成库处理二维码和产品的信息关联。" class="headerlink" title="产品信息录入和生成二维码：使用二维码生成库处理二维码和产品的信息关联。"></a>产品信息录入和生成二维码：使用二维码生成库处理二维码和产品的信息关联。</h4><h4 id="前端显示二维码：二维码中存放的是客户端的数据回显的链接（为什么不放服务器的连接呢？因为返回的是Json数据，查看不清晰）"><a href="#前端显示二维码：二维码中存放的是客户端的数据回显的链接（为什么不放服务器的连接呢？因为返回的是Json数据，查看不清晰）" class="headerlink" title="前端显示二维码：二维码中存放的是客户端的数据回显的链接（为什么不放服务器的连接呢？因为返回的是Json数据，查看不清晰）"></a>前端显示二维码：二维码中存放的是客户端的数据回显的链接（为什么不放服务器的连接呢？因为返回的是Json数据，查看不清晰）</h4><h4 id="手机端扫描二维码，"><a href="#手机端扫描二维码，" class="headerlink" title="手机端扫描二维码，"></a>手机端扫描二维码，</h4><h4 id="后端处理扫描结果（将数据重Redis缓存中获取，渲染到前端页面上，最后显示到手机端）"><a href="#后端处理扫描结果（将数据重Redis缓存中获取，渲染到前端页面上，最后显示到手机端）" class="headerlink" title="后端处理扫描结果（将数据重Redis缓存中获取，渲染到前端页面上，最后显示到手机端）"></a>后端处理扫描结果（将数据重Redis缓存中获取，渲染到前端页面上，最后显示到手机端）</h4><h4 id="前端数据显示产品的详情"><a href="#前端数据显示产品的详情" class="headerlink" title="前端数据显示产品的详情"></a>前端数据显示产品的详情</h4><h3 id="如何保证二维码数据的安全性：（除去区块链还有什么方式"><a href="#如何保证二维码数据的安全性：（除去区块链还有什么方式" class="headerlink" title="如何保证二维码数据的安全性：（除去区块链还有什么方式"></a>如何保证二维码数据的安全性：（除去区块链还有什么方式</h3><p>保护措施有蛮多的，比如：数字签名，hash算法、时间戳（数据库的篡改）、防伪码、单向链表</p>
<p>我采用的是<strong>单向链表</strong>的形式处理，我是将二维码数据设计成单向链表的形式，每个节点包含前一个节点的<strong>hash值，</strong></p>
<p>这样一来，如果有人篡改数据，需要<strong>重新计算节点的hash值</strong>，否则验证失败，从而增强数据的安全性。</p>
<h3 id="你能说一下项目中使用Redis存什么吗？"><a href="#你能说一下项目中使用Redis存什么吗？" class="headerlink" title="你能说一下项目中使用Redis存什么吗？"></a>你能说一下项目中使用Redis存什么吗？</h3><h4 id="介绍Redis"><a href="#介绍Redis" class="headerlink" title="介绍Redis"></a>介绍Redis</h4><h4 id="Redis含义："><a href="#Redis含义：" class="headerlink" title="Redis含义："></a>Redis含义：</h4><p>​	Redis是基于C语言开发的nosql，数据保存在内存中，读写速度快；好处处理高性能</p>
<h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>​	还可以用作缓存、分布式锁、消息队列、限流</p>
<h4 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h4><p>​	可以存放的数据类型：String、list 、set、有序set、hash表</p>
<h4 id="持久化："><a href="#持久化：" class="headerlink" title="持久化："></a>持久化：</h4><p>两种持久化：</p>
<ul>
<li><p>RDB：周期性以快照的形式存入磁盘内存；</p>
</li>
<li><p>AOF：将写操作放置日志文件中去。</p>
</li>
<li><p>RDB和AOF混合持久</p>
</li>
</ul>
<p>Redis设置过期时间：有利于缓解内存的消耗</p>
<p>Redis缓存</p>
<p>穿透：</p>
<ul>
<li><p>含义简单的说就是大量请求的key是不合理的。根本不存在于缓存中，也不存在于数据库中。</p>
<p>导致请求直接到数据库，加大数据库压力，可能会导致请求宕机。</p>
</li>
<li><p>解决两种方式：首先做好参数校验：缓存无效key，使用布隆过滤器</p>
</li>
</ul>
<p>击穿：</p>
<ul>
<li><p>含义就是请求key对应的热点数据，该数据存在于数据库，不存在缓存中（通常是因为缓存中的data过期）。</p>
<p>导致请求直接到数据库，加大数据库压力，可能会导致请求宕机。</p>
</li>
<li><p>解决：设置热点数据不过期；或者针对热点数据提前预热，将其存入缓存中即可；</p>
<p>请求db写数据到缓存前，先拿互斥锁，保证只有一个请求到db，减轻db压力。</p>
</li>
</ul>
<blockquote>
<p>上面二者的区别：2的key（key是热点数据）存在数据库，不在缓存；1的两个都不在。</p>
</blockquote>
<p>雪崩：</p>
<ul>
<li><p>含义：比如：data缓存在同一时间大面积失效，导致大量请求直接落到db上，压力大。就好比雪崩一样。</p>
</li>
<li><p>注意：缓存服务宕机也会导致缓存雪崩。</p>
</li>
<li><p>解决：针对Redis服务不可用时：采用Redis集群或者限流；</p>
<p>针对热点缓存失效时：设置不同的失效时间、或者设置二级缓存处理。</p>
</li>
</ul>
<blockquote>
<p>雪崩和击穿的区别：雪崩导致的是大面积失效，击穿主要是某热点数据的不存在情况。</p>
</blockquote>
<h3 id="Redis存什么？"><a href="#Redis存什么？" class="headerlink" title="Redis存什么？"></a>Redis存什么？</h3><p>Redis存放的所有农产品的信息和token值，因为农产品，当它从生产到销售这一过程全部都可以用缓存机制存取，</p>
<p>从而减轻查询数据库的压力。</p>
<h3 id="token在Redis上存什么？"><a href="#token在Redis上存什么？" class="headerlink" title="token在Redis上存什么？"></a>token在Redis上存什么？</h3><p>1、存储实际的token值，用于验证用户身份。</p>
<p>2、用户信息：比如用户ID，用户名，角色，权限等，这样验证token，从Redis查，不用每次都查DB。</p>
<p>3、token过期时间，保证数据安全性。</p>
<p>​		如果令牌刷新的处理，则是可以利用旧的token去更新后，替换原来旧的令牌</p>
<h2 id="微信ai小程序项目"><a href="#微信ai小程序项目" class="headerlink" title="微信ai小程序项目"></a>微信ai小程序项目</h2><h3 id="为什么使用websocket而不用Socket来处理你的聊天窗"><a href="#为什么使用websocket而不用Socket来处理你的聊天窗" class="headerlink" title="为什么使用websocket而不用Socket来处理你的聊天窗"></a>为什么使用websocket而不用Socket来处理你的聊天窗</h3><p>在项目中其实我是使用websocket来处理连接的，因为他有几个优点：</p>
<ul>
<li><strong>实时性</strong>：双向通信协议，可以在客户端和服务端实现实时通信，这样用户可以及时的收到其他用户发送的消息，减少等待时间</li>
<li><strong>轻量级</strong>：基于tcp协议的，使得开销更小，因为它的头部数据相对较小，减少消息的传输负载，适用于频繁的小型消息通信。</li>
<li><strong>跨平台和协议</strong>：是一种标准协议，适用于不同平台和浏览器；比传统Socket他可能要不同的操作系统和浏览器。</li>
<li><strong>集成度高</strong>：有成熟的库和框架（springboot，nodejs），可以更好集成到web应用框架中。简化它的使用和管理。</li>
</ul>
<h3 id="如何实现java和chatgpt的对接？"><a href="#如何实现java和chatgpt的对接？" class="headerlink" title="如何实现java和chatgpt的对接？"></a>如何实现java和chatgpt的对接？</h3><p>具体的一个流程：前往平台获取api key、构建http请求（post处理）、设置请求头处理（ContentType和Authorization）、</p>
<p>构建请求体（Json格式的处理）、发送http请求处理（发送到api端点）、接受处理请求、处理chatgpt的回复（流苏式输出）、</p>
<p>最后关闭连接。</p>
<h3 id="为什么要编写小程序呢，而不是用网页版？"><a href="#为什么要编写小程序呢，而不是用网页版？" class="headerlink" title="为什么要编写小程序呢，而不是用网页版？"></a>为什么要编写小程序呢，而不是用网页版？</h3><h3 id="如何解决gpt代理的问题？"><a href="#如何解决gpt代理的问题？" class="headerlink" title="如何解决gpt代理的问题？"></a>如何解决gpt代理的问题？</h3><p>我们可以创建一个Proxy对象，用来指定代理服务器的地址和端口。然后在打开连接时，将对象作为参数传递即可配置相应代理。</p>
<h3 id="存储用户信息和聊天记录（旧窗口处理）-历史记录这一板块？"><a href="#存储用户信息和聊天记录（旧窗口处理）-历史记录这一板块？" class="headerlink" title="存储用户信息和聊天记录（旧窗口处理）|| 历史记录这一板块？"></a>存储用户信息和聊天记录（旧窗口处理）|| 历史记录这一板块？</h3><h3 id="MySQL索引理解？"><a href="#MySQL索引理解？" class="headerlink" title="MySQL索引理解？"></a>MySQL索引理解？</h3><h3 id="MySQL的优化处理？"><a href="#MySQL的优化处理？" class="headerlink" title="MySQL的优化处理？"></a>MySQL的优化处理？</h3><h3 id="如果十个人同时访问你的小程序，该如何处理并发问题（使用ConcurrentHashMap）？"><a href="#如果十个人同时访问你的小程序，该如何处理并发问题（使用ConcurrentHashMap）？" class="headerlink" title="如果十个人同时访问你的小程序，该如何处理并发问题（使用ConcurrentHashMap）？"></a>如果十个人同时访问你的小程序，该如何处理并发问题（使用ConcurrentHashMap）？</h3><h3 id="concurrentHashMap和HashMap的区别？"><a href="#concurrentHashMap和HashMap的区别？" class="headerlink" title="concurrentHashMap和HashMap的区别？"></a>concurrentHashMap和HashMap的区别？</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://6wensitan.github.io">6wensitan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://6wensitan.github.io/post/62089d08.html">https://6wensitan.github.io/post/62089d08.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://6wensitan.github.io" target="_blank">Green Park</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.pixabay.com/photo/2023/08/23/12/57/young-8208513_640.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/fd3a8eda.html" title="Mybatis（短期更新）"><img class="cover" src="https://cdn.pixabay.com/photo/2023/09/05/12/29/boy-8235025_640.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mybatis（短期更新）</div></div></a></div><div class="next-post pull-right"><a href="/post/e28311eb.html" title="图解网络（基础）"><img class="cover" src="https://cdn.pixabay.com/photo/2023/07/19/22/28/amur-tiger-8138017_640.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">图解网络（基础）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%91%E5%B1%95%E8%A7%84%E5%88%92"><span class="toc-number">2.</span> <span class="toc-text">发展规划</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%9F%E6%9C%9B"><span class="toc-number">3.</span> <span class="toc-text">工作期望</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE"><span class="toc-number">4.</span> <span class="toc-text">回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%9E%90Java%E4%B8%ADvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">浅析Java中volatile关键字及其作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.1.0.1.</span> <span class="toc-text">进程和线程的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E5%88%9B%E5%BB%BA%EF%BC%89"><span class="toc-number">4.1.1.0.2.</span> <span class="toc-text">线程的两种方式（创建）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.1.1.0.3.</span> <span class="toc-text">生命周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JVM-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.2.0.1.</span> <span class="toc-text">JVM 的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JVM%E7%9A%84%E7%BB%93%E6%9E%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">4.1.2.0.2.</span> <span class="toc-text">JVM的结构组成部分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E7%94%A8"><span class="toc-number">4.1.3.</span> <span class="toc-text">volatile关键字作用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%89"><span class="toc-number">4.1.3.0.1.</span> <span class="toc-text">内存可见性（不能保证变量的原子性）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-number">4.1.3.0.2.</span> <span class="toc-text">禁止指令重排</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E6%9C%AC%E8%8A%82%E5%86%85%E5%AE%B9%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">4.1.4.</span> <span class="toc-text">对于本节内容的总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%93%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">4.2.</span> <span class="toc-text">数据结构–二叉树的先中后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E7%89%B9%E6%80%A7"><span class="toc-number">4.2.1.</span> <span class="toc-text">二叉树的递归特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.2.2.</span> <span class="toc-text">三种遍历方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81"><span class="toc-number">4.2.3.0.1.</span> <span class="toc-text">先序遍历代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81"><span class="toc-number">4.2.3.0.2.</span> <span class="toc-text">中序遍历代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81"><span class="toc-number">4.2.3.0.3.</span> <span class="toc-text">后序遍历代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-%E6%B1%82%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">4.2.3.0.4.</span> <span class="toc-text">应用:求树的深度</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.</span> <span class="toc-text">区别时间复杂度和空间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.0.1.</span> <span class="toc-text">时间复杂度:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.0.1.0.1.</span> <span class="toc-text">如何理解时间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.0.1.0.2.</span> <span class="toc-text">如何计算时间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.0.1.0.3.</span> <span class="toc-text">常见的几种时间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%A5%BD-%E6%9C%80%E5%9D%8F-%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.0.1.0.4.</span> <span class="toc-text">最好\最坏\平均时间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="toc-number">5.0.2.</span> <span class="toc-text">空间复杂度：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.0.2.0.1.</span> <span class="toc-text">如何理解空间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="toc-number">5.0.2.0.2.</span> <span class="toc-text">常见空间复杂度：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A4%E5%88%ABJava-IO%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.</span> <span class="toc-text">判别Java IO流的使用区别，以及使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">6.1.</span> <span class="toc-text">面向字节输入&#x2F;输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E7%9A%84%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">6.1.1.</span> <span class="toc-text">面向字节的输入流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%88FileInputStream%EF%BC%89"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">文件输入流（FileInputStream）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%88ByteArraryInputStream%EF%BC%89"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">字节数组输入流（ByteArraryInputStream）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%88DataInputStream%EF%BC%89"><span class="toc-number">6.1.1.3.</span> <span class="toc-text">数据输入流（DataInputStream）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E7%9A%84%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">6.1.2.</span> <span class="toc-text">面向字节的输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88FileOutputStream%EF%BC%89"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">文件输出流（FileOutputStream）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88ByteArrayOutputStream%EF%BC%89"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">字节数组输出流（ByteArrayOutputStream）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88DataOutputStream%EF%BC%89"><span class="toc-number">6.1.2.3.</span> <span class="toc-text">数据输出流（DataOutputStream）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">6.2.</span> <span class="toc-text">面向字符输入&#x2F;输出流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">6.3.</span> <span class="toc-text">转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.3.0.1.</span> <span class="toc-text">编码格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8"><span class="toc-number">6.3.0.2.</span> <span class="toc-text">实际使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB%EF%BC%9AFileWriter%E2%80%94FileReader%E7%B1%BB"><span class="toc-number">6.4.</span> <span class="toc-text">使用区别：FileWriter—FileReader类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FileWriter%EF%BC%9A"><span class="toc-number">6.4.0.1.</span> <span class="toc-text">FileWriter：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileReader%EF%BC%9A"><span class="toc-number">6.4.0.2.</span> <span class="toc-text">FileReader：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85%E8%A3%85%E6%B5%81%EF%BC%9ABufferedWriter%E2%80%93BufferedReader%E7%B1%BB"><span class="toc-number">6.5.</span> <span class="toc-text">常用的包装流：BufferedWriter–BufferedReader类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedWriter%EF%BC%9A"><span class="toc-number">6.5.0.1.</span> <span class="toc-text">BufferedWriter：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedReader%EF%BC%9A"><span class="toc-number">6.5.0.2.</span> <span class="toc-text">BufferedReader：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%94%A8%E7%9A%84%E5%86%99%E5%85%A5%E6%B5%81%EF%BC%9APrintWriter%E7%B1%BB"><span class="toc-number">6.6.</span> <span class="toc-text">非常好用的写入流：PrintWriter类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%9B%9E%E9%A1%BE"><span class="toc-number">7.</span> <span class="toc-text">Linux回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">7.1.</span> <span class="toc-text">查找可执行文件的指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#whereis"><span class="toc-number">7.1.0.1.</span> <span class="toc-text">whereis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#locate"><span class="toc-number">7.1.0.2.</span> <span class="toc-text">locate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#which"><span class="toc-number">7.1.0.3.</span> <span class="toc-text">which</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#type"><span class="toc-number">7.1.0.4.</span> <span class="toc-text">type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find"><span class="toc-number">7.1.0.5.</span> <span class="toc-text">find</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%93%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">8.1.</span> <span class="toc-text">多线程–守护线程和非守护线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="toc-number">8.1.0.1.</span> <span class="toc-text">守护线程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="toc-number">8.1.0.2.</span> <span class="toc-text">非守护线程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">8.1.0.3.</span> <span class="toc-text">实例代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">8.1.0.4.</span> <span class="toc-text">注意事项：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">8.1.0.5.</span> <span class="toc-text">自定义守护线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E4%BA%8E%E5%AE%9E%E4%BD%93%E7%B1%BB%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%BE%E7%BD%AE-%E9%9C%80%E8%A6%81%E8%AF%A5%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">8.1.0.6.</span> <span class="toc-text">针对于实体类的缓存设置:需要该类实现序列化.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Mybatis%E4%B8%AD%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">在Mybatis中乐观锁和悲观锁是什么，如何应用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">什么是数据持久化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B"><span class="toc-number">8.4.</span> <span class="toc-text">MyBatis框架简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFORM%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">什么是ORM？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.6.</span> <span class="toc-text">MyBatis的优缺点和使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">8.6.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">8.6.2.</span> <span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E5%90%88%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">8.6.3.</span> <span class="toc-text">适合场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.7.</span> <span class="toc-text">#{}和${}的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%91%A2%EF%BC%9F"><span class="toc-number">8.8.</span> <span class="toc-text">当实体类中的属性名和表中的字段名不一样，怎么处理呢？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">SpringBoot常见问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%AF%B7%E7%AE%80%E8%BF%B0-RequestBody-RequestParam-PathVariable%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">9.1.</span> <span class="toc-text">1、请简述@RequestBody @RequestParam @PathVariable三者区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81SpringMVC%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.2.</span> <span class="toc-text">2、SpringMVC底层原理是什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">HashMap常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">10.0.0.1.</span> <span class="toc-text">1、数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">10.0.0.2.</span> <span class="toc-text">2、HashMap的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%BD%93%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84hashcode%E7%9B%B8%E5%90%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.0.0.3.</span> <span class="toc-text">3、当两个对象的hashcode相同会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93Hash%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%91%A2%EF%BC%9F"><span class="toc-number">10.0.0.4.</span> <span class="toc-text">4、你知道Hash的实现吗？为什么要这么实现呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9F"><span class="toc-number">10.0.0.5.</span> <span class="toc-text">5、为什么要用异或运算符？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81HashMap%E7%9A%84table%E7%9A%84%E5%AE%B9%E9%87%8F%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%EF%BC%9F"><span class="toc-number">10.0.0.6.</span> <span class="toc-text">6、HashMap的table的容量如何确定？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81loadFactor%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%A5%E5%AE%B9%E9%87%8F%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%EF%BC%9F%E8%BF%99%E4%B8%AA%E5%8F%98%E5%8C%96%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">10.0.0.7.</span> <span class="toc-text">7、loadFactor是什么？该容量如何变化？这个变化会带来什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80%EF%BC%9A"><span class="toc-number">10.0.0.7.1.</span> <span class="toc-text">问题一：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%9A"><span class="toc-number">10.0.0.7.2.</span> <span class="toc-text">问题二：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%89%EF%BC%9A"><span class="toc-number">10.0.0.7.3.</span> <span class="toc-text">问题三：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%A7%81%E8%A7%A3%EF%BC%9F"><span class="toc-number">10.0.0.8.</span> <span class="toc-text">8、说说你对红黑树的见解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81HashMap%E3%80%81linkedHashMap%E3%80%81treeMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.0.0.9.</span> <span class="toc-text">9、HashMap、linkedHashMap、treeMap的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81HashMap%E3%80%81linkedHashMap%E3%80%81treeMap%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">10.0.0.10.</span> <span class="toc-text">10、HashMap、linkedHashMap、treeMap使用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81%E5%8C%BA%E5%88%AB%EF%BC%9AHashMap%E2%80%94HashTable"><span class="toc-number">10.0.0.11.</span> <span class="toc-text">11、区别：HashMap—HashTable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81HashMap%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">10.0.0.12.</span> <span class="toc-text">12、HashMap的不安全体现在哪里？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81HashMap%E6%80%8E%E6%A0%B7%E8%A7%A3%E5%86%B3Hash%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-number">10.0.0.13.</span> <span class="toc-text">13、HashMap怎样解决Hash冲突？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81HashMap%E5%92%8CConcurrentHashMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">10.0.0.14.</span> <span class="toc-text">14、HashMap和ConcurrentHashMap的区别？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E5%9B%9E%E9%A1%BE"><span class="toc-number">11.</span> <span class="toc-text">Java基础常见面试回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-number">11.1.</span> <span class="toc-text">Java常见面试题（上）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B8%B8%E8%AF%86"><span class="toc-number">11.1.1.</span> <span class="toc-text">基础概念和常识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="toc-number">11.1.1.1.</span> <span class="toc-text">Java语言特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-SE-vs-Java-EE"><span class="toc-number">11.1.1.2.</span> <span class="toc-text">Java SE vs Java EE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM-vs-JDK-vs-JRE"><span class="toc-number">11.1.1.3.</span> <span class="toc-text">JVM vs JDK vs JRE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F%E9%87%87%E7%94%A8%E5%AE%83%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.1.1.4.</span> <span class="toc-text">什么是字节码？采用它的好处是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Java%E8%AF%AD%E8%A8%80%E2%80%9C%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98%E2%80%9D%EF%BC%9F"><span class="toc-number">11.1.1.5.</span> <span class="toc-text">为什么说Java语言“编译与解释并存”？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOT%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%A8%E9%83%A8%E4%BD%BF%E7%94%A8AOT%E5%91%A2%EF%BC%9F"><span class="toc-number">11.1.1.6.</span> <span class="toc-text">AOT有什么优点？为什么不全部使用AOT呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-JDK-vs-Open-JDK"><span class="toc-number">11.1.1.7.</span> <span class="toc-text">Oracle JDK vs Open JDK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">11.1.1.8.</span> <span class="toc-text">&#x3D;&#x3D;Java和C++的区别？&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">11.1.2.</span> <span class="toc-text">基础语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">11.2.</span> <span class="toc-text">Java常见面试题（中）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-number">11.3.</span> <span class="toc-text">Java常见面试题（下）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%8C%E4%B8%8A%E5%88%B7%E9%A2%98%E5%AE%9D"><span class="toc-number">12.</span> <span class="toc-text">掌上刷题宝</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%8F%98%E9%87%8F"><span class="toc-number">12.1.</span> <span class="toc-text">Java变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">12.2.</span> <span class="toc-text">this关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">12.3.</span> <span class="toc-text">Java返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%91%BD%E5%90%8D"><span class="toc-number">12.4.</span> <span class="toc-text">Java命名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%90%AB%E4%B9%89"><span class="toc-number">12.5.</span> <span class="toc-text">Java含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%90%AB%E4%B9%89"><span class="toc-number">12.6.</span> <span class="toc-text">JVM含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JRE%E5%90%AB%E4%B9%89"><span class="toc-number">12.7.</span> <span class="toc-text">JRE含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK%E5%90%AB%E4%B9%89"><span class="toc-number">12.8.</span> <span class="toc-text">JDK含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9-1"><span class="toc-number">12.9.</span> <span class="toc-text">Java语言特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK1-8%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">12.10.</span> <span class="toc-text">JDK1.8新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.11.</span> <span class="toc-text">重写和重载的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.12.</span> <span class="toc-text">抽象类和接口的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">12.13.</span> <span class="toc-text">IO流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A5%BD%E5%A4%84"><span class="toc-number">12.14.</span> <span class="toc-text">多线程好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E4%B8%AA%E7%89%B9%E5%BE%81"><span class="toc-number">12.15.</span> <span class="toc-text">理解面向对象三个特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E6%A0%88%E3%80%81%E5%A0%86"><span class="toc-number">12.16.</span> <span class="toc-text">Java数据结构：栈、堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%A0%86%E7%A9%BA%E9%97%B4%E5%92%8CGC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">12.17.</span> <span class="toc-text">理解堆空间和GC垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B"><span class="toc-number">12.18.</span> <span class="toc-text">理解泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%8F%8D%E5%B0%84"><span class="toc-number">12.19.</span> <span class="toc-text">理解反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E5%8C%BA%E5%88%AB"><span class="toc-number">12.20.</span> <span class="toc-text">String、StringBuffer、StringBuilder区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.21.</span> <span class="toc-text">进程和线程的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%9B%8A%E7%BD%91%E7%BB%9C%EF%BC%9A"><span class="toc-number">13.</span> <span class="toc-text">多益网络：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">13.1.</span> <span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E6%85%A7%E9%A1%B9%E7%9B%AE"><span class="toc-number">13.2.</span> <span class="toc-text">智慧项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E6%85%A7%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%86%E5%B7%A5%EF%BC%9A"><span class="toc-number">13.2.1.</span> <span class="toc-text">智慧项目的分工：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%BD%E6%BA%AF%E4%BF%A1%E6%81%AF%E7%9A%84"><span class="toc-number">13.2.2.</span> <span class="toc-text">讲一下二维码是如何追溯信息的.</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A7%E5%93%81%E4%BF%A1%E6%81%AF%E5%BD%95%E5%85%A5%E5%92%8C%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90%E5%BA%93%E5%A4%84%E7%90%86%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%92%8C%E4%BA%A7%E5%93%81%E7%9A%84%E4%BF%A1%E6%81%AF%E5%85%B3%E8%81%94%E3%80%82"><span class="toc-number">13.2.2.1.</span> <span class="toc-text">产品信息录入和生成二维码：使用二维码生成库处理二维码和产品的信息关联。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%98%BE%E7%A4%BA%E4%BA%8C%E7%BB%B4%E7%A0%81%EF%BC%9A%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%B8%AD%E5%AD%98%E6%94%BE%E7%9A%84%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE%E7%9A%84%E9%93%BE%E6%8E%A5%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%91%A2%EF%BC%9F%E5%9B%A0%E4%B8%BA%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AFJson%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%B8%8D%E6%B8%85%E6%99%B0%EF%BC%89"><span class="toc-number">13.2.2.2.</span> <span class="toc-text">前端显示二维码：二维码中存放的是客户端的数据回显的链接（为什么不放服务器的连接呢？因为返回的是Json数据，查看不清晰）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E6%9C%BA%E7%AB%AF%E6%89%AB%E6%8F%8F%E4%BA%8C%E7%BB%B4%E7%A0%81%EF%BC%8C"><span class="toc-number">13.2.2.3.</span> <span class="toc-text">手机端扫描二维码，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E5%A4%84%E7%90%86%E6%89%AB%E6%8F%8F%E7%BB%93%E6%9E%9C%EF%BC%88%E5%B0%86%E6%95%B0%E6%8D%AE%E9%87%8DRedis%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96%EF%BC%8C%E6%B8%B2%E6%9F%93%E5%88%B0%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E4%B8%8A%EF%BC%8C%E6%9C%80%E5%90%8E%E6%98%BE%E7%A4%BA%E5%88%B0%E6%89%8B%E6%9C%BA%E7%AB%AF%EF%BC%89"><span class="toc-number">13.2.2.4.</span> <span class="toc-text">后端处理扫描结果（将数据重Redis缓存中获取，渲染到前端页面上，最后显示到手机端）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA%E4%BA%A7%E5%93%81%E7%9A%84%E8%AF%A6%E6%83%85"><span class="toc-number">13.2.2.5.</span> <span class="toc-text">前端数据显示产品的详情</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9A%EF%BC%88%E9%99%A4%E5%8E%BB%E5%8C%BA%E5%9D%97%E9%93%BE%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F"><span class="toc-number">13.2.3.</span> <span class="toc-text">如何保证二维码数据的安全性：（除去区块链还有什么方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8B%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Redis%E5%AD%98%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F"><span class="toc-number">13.2.4.</span> <span class="toc-text">你能说一下项目中使用Redis存什么吗？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8DRedis"><span class="toc-number">13.2.4.1.</span> <span class="toc-text">介绍Redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%90%AB%E4%B9%89%EF%BC%9A"><span class="toc-number">13.2.4.2.</span> <span class="toc-text">Redis含义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">13.2.4.3.</span> <span class="toc-text">应用场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">13.2.4.4.</span> <span class="toc-text">数据类型：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9A"><span class="toc-number">13.2.4.5.</span> <span class="toc-text">持久化：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AD%98%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">13.2.5.</span> <span class="toc-text">Redis存什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#token%E5%9C%A8Redis%E4%B8%8A%E5%AD%98%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">13.2.6.</span> <span class="toc-text">token在Redis上存什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E4%BF%A1ai%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE"><span class="toc-number">13.3.</span> <span class="toc-text">微信ai小程序项目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8websocket%E8%80%8C%E4%B8%8D%E7%94%A8Socket%E6%9D%A5%E5%A4%84%E7%90%86%E4%BD%A0%E7%9A%84%E8%81%8A%E5%A4%A9%E7%AA%97"><span class="toc-number">13.3.1.</span> <span class="toc-text">为什么使用websocket而不用Socket来处理你的聊天窗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0java%E5%92%8Cchatgpt%E7%9A%84%E5%AF%B9%E6%8E%A5%EF%BC%9F"><span class="toc-number">13.3.2.</span> <span class="toc-text">如何实现java和chatgpt的对接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BC%96%E5%86%99%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%91%A2%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E7%94%A8%E7%BD%91%E9%A1%B5%E7%89%88%EF%BC%9F"><span class="toc-number">13.3.3.</span> <span class="toc-text">为什么要编写小程序呢，而不是用网页版？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3gpt%E4%BB%A3%E7%90%86%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">13.3.4.</span> <span class="toc-text">如何解决gpt代理的问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E5%92%8C%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95%EF%BC%88%E6%97%A7%E7%AA%97%E5%8F%A3%E5%A4%84%E7%90%86%EF%BC%89-%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E8%BF%99%E4%B8%80%E6%9D%BF%E5%9D%97%EF%BC%9F"><span class="toc-number">13.3.5.</span> <span class="toc-text">存储用户信息和聊天记录（旧窗口处理）|| 历史记录这一板块？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%B4%A2%E5%BC%95%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">13.3.6.</span> <span class="toc-text">MySQL索引理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E7%9A%84%E4%BC%98%E5%8C%96%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">13.3.7.</span> <span class="toc-text">MySQL的优化处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%8D%81%E4%B8%AA%E4%BA%BA%E5%90%8C%E6%97%B6%E8%AE%BF%E9%97%AE%E4%BD%A0%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%88%E4%BD%BF%E7%94%A8ConcurrentHashMap%EF%BC%89%EF%BC%9F"><span class="toc-number">13.3.8.</span> <span class="toc-text">如果十个人同时访问你的小程序，该如何处理并发问题（使用ConcurrentHashMap）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrentHashMap%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">13.3.9.</span> <span class="toc-text">concurrentHashMap和HashMap的区别？</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.pixabay.com/photo/2023/08/23/12/57/young-8208513_640.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 6wensitan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/js/sun_moon.js" async></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>