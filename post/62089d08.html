<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试整合（长期更新） | Green Park</title><meta name="author" content="6wensitan"><meta name="copyright" content="6wensitan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="回顾 浅析Java中volatile关键字及其作用 在Java多线程如何保证线程的安全性？我们可以使用“Synchronized”同步锁保证线程安全。（弊端：消耗资源） 首先得了解：多线程和JVM 多线程进程和线程的概念 进程：一个正在执行的程序，动态的，是系统进行资源分配和调度的独立单位。 进程中一个独立的控制单元，线程控制着进程的执行，。一个进程中至少有一个线程  线程的两种方式（创建） 继承">
<meta property="og:type" content="article">
<meta property="og:title" content="面试整合（长期更新）">
<meta property="og:url" content="http://example.com/post/62089d08.html">
<meta property="og:site_name" content="Green Park">
<meta property="og:description" content="回顾 浅析Java中volatile关键字及其作用 在Java多线程如何保证线程的安全性？我们可以使用“Synchronized”同步锁保证线程安全。（弊端：消耗资源） 首先得了解：多线程和JVM 多线程进程和线程的概念 进程：一个正在执行的程序，动态的，是系统进行资源分配和调度的独立单位。 进程中一个独立的控制单元，线程控制着进程的执行，。一个进程中至少有一个线程  线程的两种方式（创建） 继承">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.pixabay.com/photo/2023/08/23/12/57/young-8208513_640.jpg">
<meta property="article:published_time" content="2023-09-23T06:14:37.000Z">
<meta property="article:modified_time" content="2023-10-15T07:02:21.904Z">
<meta property="article:author" content="6wensitan">
<meta property="article:tag" content="刷题回顾">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.pixabay.com/photo/2023/08/23/12/57/young-8208513_640.jpg"><link rel="shortcut icon" href="/img/nnwm.jpg"><link rel="canonical" href="http://example.com/post/62089d08.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'mediumZoom',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试整合（长期更新）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-15 15:02:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/nnwm.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.pixabay.com/photo/2023/08/23/12/57/young-8208513_640.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Green Park"><span class="site-name">Green Park</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试整合（长期更新）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-23T06:14:37.000Z" title="发表于 2023-09-23 14:14:37">2023-09-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-15T07:02:21.904Z" title="更新于 2023-10-15 15:02:21">2023-10-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/jiepu/">jiepu</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><hr>
<h2 id="浅析Java中volatile关键字及其作用"><a href="#浅析Java中volatile关键字及其作用" class="headerlink" title="浅析Java中volatile关键字及其作用"></a>浅析Java中volatile关键字及其作用</h2><hr>
<p>在Java多线程如何保证线程的安全性？我们可以使用“Synchronized”同步锁保证线程安全。（弊端：消耗资源）</p>
<p>首先得了解：多线程和JVM</p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h5 id="进程和线程的概念"><a href="#进程和线程的概念" class="headerlink" title="进程和线程的概念"></a>进程和线程的概念</h5><ul>
<li>进程：一个正在执行的程序，<strong>动态的</strong>，是系统进行资源分配和调度的独立<strong>单位</strong>。</li>
<li>进程中一个独立的控制单元，线程控制着进程的执行，。<strong>一个进程中至少有一个线程</strong></li>
</ul>
<h5 id="线程的两种方式（创建）"><a href="#线程的两种方式（创建）" class="headerlink" title="线程的两种方式（创建）"></a>线程的两种方式（创建）</h5><ul>
<li><p>继承Thread类：定义继承Thread类、重写run方法、调用该线程start方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// step2：创建该类的对象</span></span><br><span class="line">		<span class="type">Lefthand</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lefthand</span>();</span><br><span class="line">		<span class="type">Righthand</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Righthand</span>();</span><br><span class="line">		<span class="comment">// step3：调用start方法启动线程</span></span><br><span class="line">		left.start();</span><br><span class="line">		right.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// step1：继承Thread类，在子类中必须实现run方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lefthand</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;You are Students!&quot;</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				sleep(<span class="number">500</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Righthand</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;I am a Teacher!&quot;</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				sleep(<span class="number">300</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现Runnable接口：定义实现Runnable接口、实现run方法、通过Thread类建立线程对象、start方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoThreadsDemo2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">SimpleThread2</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleThread2</span>(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">		<span class="type">SimpleThread2</span> <span class="variable">th2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleThread2</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">		<span class="comment">// step3</span></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(th1);</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(th2);</span><br><span class="line">		thread1.start();</span><br><span class="line">		thread2.start();</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// step1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SimpleThread2</span><span class="params">(String str)</span> &#123;</span><br><span class="line">		name = str;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// step2</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">			System.out.println(i + <span class="string">&quot; &quot;</span> + name);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;DONE!&quot;</span> + name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意两种方式区别：第二种避免单继承的局限性，线程代码存在接口子类型中。</p>
</blockquote>
</li>
</ul>
<h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><ul>
<li>就绪状态（创建线程）、可执行线程（start启动线程，调用run方法）、阻塞状态（sleep和wait）、死亡状态（stop）</li>
</ul>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h5 id="JVM-的概念"><a href="#JVM-的概念" class="headerlink" title="JVM 的概念"></a>JVM 的概念</h5><ul>
<li>Java虚拟机定义是抽象的规范，使Java可以具有跨平台的运行。他<strong>决定一个线程对共享变量的写入何时对另一个线程可见性</strong></li>
</ul>
<h5 id="JVM的结构组成部分"><a href="#JVM的结构组成部分" class="headerlink" title="JVM的结构组成部分"></a>JVM的结构组成部分</h5><ul>
<li><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/70.png" alt="img"></li>
<li>主内存：线程共享（本体）</li>
<li>工作内存：线程私有（副本）</li>
<li>线程对共享变量的所有操作全在工作内存中进行；变量值的传递只能在主内存中完成。</li>
</ul>
<h3 id="volatile关键字作用"><a href="#volatile关键字作用" class="headerlink" title="volatile关键字作用"></a>volatile关键字作用</h3><h5 id="内存可见性（不能保证变量的原子性）"><a href="#内存可见性（不能保证变量的原子性）" class="headerlink" title="内存可见性（不能保证变量的原子性）"></a>内存可见性（不能保证变量的原子性）</h5><ul>
<li><p>某线程对volatile修饰变量的修改，其他线程是可见的，每次获取该变量都是最新的值。</p>
</li>
<li><p>该特性体现Java原则之一：先行发生原则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//线程 A 在其工作内存中写入变量 a 的新值 1</span></span><br><span class="line">a = <span class="number">1</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程 B 在主内存中读取变量 a 的值输出</span></span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用该关键字并体现该特性的条件：</p>
<p>​			1、能确保只有单一的线程对共享变量的只进行修改</p>
<p>​			2、变量不需要和其他状态共同参与不变的约束条件</p>
</blockquote>
</li>
</ul>
<h5 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h5><ul>
<li><p>指令重排：JVM在编译Java代码时或者CPU在执行JVM字节码时，对现有指令进行重新排序（前提是不改变程序结果），优化运行效率。</p>
</li>
<li><p>执行排序的约束，（解决多线程问题）-》<strong>内存屏障</strong></p>
</li>
<li><p>内存屏障是一种屏障指令，分四种类型：LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障；</p>
</li>
<li><p>针对于volatile变量上的体现：（JVM执行）</p>
<ul>
<li>对每一个volatile变量写入前：<strong>StoreStore屏障</strong></li>
<li>对写之后：<strong>StoreLoad屏障</strong></li>
<li>对读操作之前：<strong>LoadLoad屏障</strong></li>
<li>对读之后：<strong>LoadStore屏障</strong></li>
</ul>
</li>
<li><p>不能保证线程安全性</p>
</li>
</ul>
<h3 id="对于本节内容的总结："><a href="#对于本节内容的总结：" class="headerlink" title="对于本节内容的总结："></a>对于本节内容的<strong>总结</strong>：</h3><ul>
<li>volatile具有内存可见性，基于屏障指令；</li>
<li>volatile具有禁止指令重排，在编译时：JVM遵循内存屏障的约束，运行时：屏障指令组织重排。</li>
<li>Synchronized关键字：保证变量原子性和可见性；volatile不能保证原子性、线程不安全</li>
</ul>
<h2 id="数据结构–二叉树的先中后序遍历"><a href="#数据结构–二叉树的先中后序遍历" class="headerlink" title="数据结构–二叉树的先中后序遍历"></a>数据结构–二叉树的先中后序遍历</h2><hr>
<h3 id="二叉树的递归特性"><a href="#二叉树的递归特性" class="headerlink" title="二叉树的递归特性"></a>二叉树的递归特性</h3><ul>
<li>空二叉树</li>
<li>根节点+左子树+右子树组成的二叉树</li>
</ul>
<h3 id="三种遍历方式："><a href="#三种遍历方式：" class="headerlink" title="三种遍历方式："></a>三种遍历方式：</h3><blockquote>
<p>注意：该遍历方式也是一种递归的方式</p>
</blockquote>
<ul>
<li>先序（前序）：根左右（NLR）<ul>
<li>先访问<strong>根</strong>节点，再访问该根节点的左子树节点，最后该根节点的右子树；当然该左子树或右子树分支节点，也根据此遍历方式。</li>
</ul>
</li>
<li>中序：左根右（LNR）<ul>
<li>先访问<strong>左子树</strong>节点，再到<strong>根</strong>节点，最后才是右子树节点；当然还有分支也是如此遍历下去。</li>
</ul>
</li>
<li>后序：左右根（LRN）<ul>
<li>先访问左子树节点，再到<strong>右子树</strong>节点，最后根子数节点；当然还有分支也是如此遍历下去。</li>
</ul>
</li>
</ul>
<p><strong>下面是图例：</strong></p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/97c72517666e46448a3ceb29cc807c2a.png" alt="img"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h5 id="先序遍历代码"><a href="#先序遍历代码" class="headerlink" title="先序遍历代码"></a>先序遍历代码</h5><ul>
<li><p>若二叉树为null，则什么也不做</p>
</li>
<li><p>非空时：先访问根节点；先序遍历左子树；先序遍历右子树。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		visit(T);                访问根结点，visit()执行相关访问操作的函数，比如打印...</span><br><span class="line">		PreOrder(T-&gt;lchild);     <span class="comment">//递归遍历左子树</span></span><br><span class="line">		PreOrder(T-&gt;rchild);     <span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="中序遍历代码"><a href="#中序遍历代码" class="headerlink" title="中序遍历代码"></a>中序遍历代码</h5><ul>
<li><p>二叉树&#x3D;null，什么也不做</p>
</li>
<li><p>二叉树！&#x3D;null：先访问左子树节点，再到根节点，最后右子树节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		InOrder(T-&gt;lchild);		<span class="comment">//递归遍历左子树</span></span><br><span class="line">		visit(T);				<span class="comment">//访问根结点</span></span><br><span class="line">		InOrder(T-&gt;rchild);		<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="后序遍历代码"><a href="#后序遍历代码" class="headerlink" title="后序遍历代码"></a>后序遍历代码</h5><ul>
<li><p>二叉树&#x3D;null，什么也不做</p>
</li>
<li><p>二叉树！&#x3D;null：先访问左子树节点，再到右子树节点，最后根节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (T != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		PostOrder(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">		PostOrder(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">		visit(T);				<span class="comment">//访问根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="应用-求树的深度"><a href="#应用-求树的深度" class="headerlink" title="应用:求树的深度"></a>应用:求树的深度</h5><ul>
<li><p>后序遍历算法改编：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">treeDepth</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> l = treeDepth(T-&gt;lchild);</span><br><span class="line">		<span class="type">int</span> r = treeDepth(T-&gt;rchild);</span><br><span class="line">		<span class="keyword">return</span> l &gt; r ? l + <span class="number">1</span> : r + <span class="number">1</span>;		<span class="comment">//树的深度=Max(左子树深度,右子树深度)+1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="区别时间复杂度和空间复杂度"><a href="#区别时间复杂度和空间复杂度" class="headerlink" title="区别时间复杂度和空间复杂度"></a>区别时间复杂度和空间复杂度</h1><hr>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度:"></a>时间复杂度:</h3><blockquote>
<p>T（n）&#x3D;O（f（n））</p>
<p>T表示算法执行时间，n表示数据规模；成正比的计算</p>
</blockquote>
<h5 id="如何理解时间复杂度"><a href="#如何理解时间复杂度" class="headerlink" title="如何理解时间复杂度"></a>如何理解时间复杂度</h5><ul>
<li>表示代码的执行时间随着数据规模的增长趋势，而不是具体的执行时间</li>
<li>通常只是表示数据规模n很大的时候的执行效率</li>
</ul>
<h5 id="如何计算时间复杂度"><a href="#如何计算时间复杂度" class="headerlink" title="如何计算时间复杂度"></a>如何计算时间复杂度</h5><ul>
<li>忽略常量、系数、只保留最高量级</li>
<li>总时间复杂度&#x3D;量级最大代码的执行时间复杂度</li>
<li><strong>嵌套代码的复杂度&#x3D;嵌套内外复杂度的乘积</strong></li>
</ul>
<h5 id="常见的几种时间复杂度"><a href="#常见的几种时间复杂度" class="headerlink" title="常见的几种时间复杂度"></a>常见的几种时间复杂度</h5><ul>
<li>O(1)：常量级：Hash表上的各种操作</li>
<li><strong>O(logn)<strong>：对数级：</strong>二分查找</strong>、调表</li>
<li>O(n)：线性：数组，链表<strong>遍历</strong></li>
<li><strong>O(nlogn)<strong>：快排、</strong>归并排序</strong></li>
<li><strong>O(n^2)：冒泡、插入、选择排序</strong></li>
<li>O(2^n)：指数级：回溯穷举法</li>
<li>O(n!)：求全排列</li>
</ul>
<h5 id="最好-最坏-平均时间复杂度"><a href="#最好-最坏-平均时间复杂度" class="headerlink" title="最好\最坏\平均时间复杂度"></a>最好\最坏\平均时间复杂度</h5><blockquote>
<p>例子：在数组中找某个值，遍历的情况</p>
</blockquote>
<ul>
<li>最好时间复杂度<ul>
<li>O(1)。（接口的最小相应时间）</li>
</ul>
</li>
<li>最坏时间复杂度<ul>
<li>O(n)。（最大）</li>
</ul>
</li>
<li>平均时间复杂度<ul>
<li>O(n)。（平均）–大多数情况下：平均就是最坏的时间复杂度</li>
</ul>
</li>
<li>均摊时间复杂度<ul>
<li>是特殊的平均时间复杂度，常见：动态扩容</li>
</ul>
</li>
</ul>
<h3 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h3><h5 id="如何理解空间复杂度"><a href="#如何理解空间复杂度" class="headerlink" title="如何理解空间复杂度"></a>如何理解空间复杂度</h5><ul>
<li>是度量算法运行过程占用的存储空间，通常使用S（n）表示，n表示问题的规模。</li>
</ul>
<h5 id="常见空间复杂度："><a href="#常见空间复杂度：" class="headerlink" title="常见空间复杂度："></a>常见空间复杂度：</h5><ul>
<li><p>O(1)：代码中m\n所分配的空间都是常量级的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>


</li>
<li><p>O(n)：代码中使用array数组保存变量，随着n的值增大，数组所占空间也越大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[n]</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   array[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="判别Java-IO流的使用区别，以及使用场景"><a href="#判别Java-IO流的使用区别，以及使用场景" class="headerlink" title="判别Java IO流的使用区别，以及使用场景"></a>判别Java IO流的使用区别，以及使用场景</h1><hr>
<h2 id="面向字节输入-输出流"><a href="#面向字节输入-输出流" class="headerlink" title="面向字节输入&#x2F;输出流"></a>面向字节输入&#x2F;输出流</h2><h3 id="面向字节的输入流"><a href="#面向字节的输入流" class="headerlink" title="面向字节的输入流"></a>面向字节的输入流</h3><blockquote>
<p>在java.io包下，InputStream类表示字节输入流，特点：抽象、不能实例化、。面向字节的输入流都是该类的子类</p>
</blockquote>
<p>如下图：</p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjEyMjI3MQ==,size_16,color_FFFFFF,t_70.png" alt="1111111"></p>
<h4 id="文件输入流（FileInputStream）"><a href="#文件输入流（FileInputStream）" class="headerlink" title="文件输入流（FileInputStream）"></a>文件输入流（FileInputStream）</h4><ul>
<li><p>用于读取二进制文件数据，利用new创建对象，构造方法有：</p>
<ul>
<li><p>FileInputStream（File file）：打开一个实际文件链接来创建文件输入流，有文件系统的File对象指定。</p>
</li>
<li><p>FileInputStream（String name）：根据文件系统的路径名name指定读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			FileInputStream file=<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;e:/新建文本文档.txt&quot;</span>);    <span class="comment">//创建一个FileInputStream类实例对象file</span></span><br><span class="line">			<span class="type">int</span> byteRead=file.read();            <span class="comment">//创建一个byteRead变量存储读一个字节</span></span><br><span class="line">			<span class="keyword">while</span>(byteRead!=-<span class="number">1</span>) &#123;                <span class="comment">//如果返回值不是-1则继续执行file的读操作</span></span><br><span class="line">				System.out.print((<span class="type">char</span>)byteRead);    <span class="comment">//将int类型转换为char类型并输出</span></span><br><span class="line">				byteRead=file.read();    </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span>(ArrayIndexOutOfBoundsException e) &#123;        <span class="comment">//访问数组元素下标越界的异常</span></span><br><span class="line">			System.out.println(<span class="string">&quot;要一个文件名作为命令行参数！&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(FileNotFoundException e) &#123;                 <span class="comment">//访问文件不存在的异常</span></span><br><span class="line">			System.out.println(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;&#125;                          <span class="comment">//输入输出异常</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="字节数组输入流（ByteArraryInputStream）"><a href="#字节数组输入流（ByteArraryInputStream）" class="headerlink" title="字节数组输入流（ByteArraryInputStream）"></a>字节数组输入流（ByteArraryInputStream）</h4><ul>
<li><p>从内存的字节数组中读取数据(数据源是一个字节数组),把字节数组转为输入流类型</p>
<ul>
<li><p>采用<strong>适配器设计模式</strong>,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		String str=<span class="string">&quot;123456789qwerty&quot;</span>;        <span class="comment">//创建一个字符串变量</span></span><br><span class="line">		<span class="type">byte</span>[]strBuf=str.getBytes();         <span class="comment">//把字符串转换为字节数组</span></span><br><span class="line">		ByteArrayInputStream bais=<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(strBuf);    <span class="comment">//创建一个字节数组流对象</span></span><br><span class="line">		<span class="type">int</span> data=bais.read();                 <span class="comment">//从字节数组输入流读取字节</span></span><br><span class="line">		<span class="keyword">while</span>(data!=-<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="type">char</span> upper=Character.toUpperCase((<span class="type">char</span>)data);    <span class="comment">//小写转换为大写</span></span><br><span class="line">			System.out.print(upper+<span class="string">&quot; &quot;</span>);</span><br><span class="line">			data=bais.read();                 <span class="comment">//读取字节</span></span><br><span class="line">		&#125;</span><br><span class="line">		bais.close();                         <span class="comment">//关闭字节数组输入流</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> Q W E R T Y </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="数据输入流（DataInputStream）"><a href="#数据输入流（DataInputStream）" class="headerlink" title="数据输入流（DataInputStream）"></a>数据输入流（DataInputStream）</h4><h3 id="面向字节的输出流"><a href="#面向字节的输出流" class="headerlink" title="面向字节的输出流"></a>面向字节的输出流</h3><blockquote>
<p> 面向字节的输出流都是类OutputStream的后代类</p>
</blockquote>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjEyMjI3MQ==,size_16,color_FFFFFF,t_70-16954594534474.png" alt="132543"></p>
<h4 id="文件输出流（FileOutputStream）"><a href="#文件输出流（FileOutputStream）" class="headerlink" title="文件输出流（FileOutputStream）"></a>文件输出流（FileOutputStream）</h4><ul>
<li><p>向二进制文件写入数据,构造方法:</p>
<ul>
<li>FileOutputStream(String name,boolean append):创建一个向指定名字的文件写入数据,若第二个参数为true,则添加方式写入字节,且文件中原有数据不删除;</li>
<li>FileOutputStream(File file,boolean):创建一个向指定File对象表示的文件中写入数据流,若第二个参数为true,则将字节写入文件末尾;</li>
</ul>
<p>实例:使用文件输入流将100-200之间可以被3整除的数写到文本中,要求每一行10个.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		<span class="type">int</span> n,num,i=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			FileOutputStream fos=<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:/t.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">for</span>(n=<span class="number">100</span>;n&lt;=<span class="number">200</span>;n++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">0</span>) &#123;</span><br><span class="line">					i++;</span><br><span class="line">					String str=String.valueOf(n);</span><br><span class="line">					String str1=str+<span class="string">&quot; &quot;</span>;</span><br><span class="line">					<span class="type">byte</span>[]buff=str1.getBytes();</span><br><span class="line">					fos.write(buff);</span><br><span class="line">					<span class="keyword">if</span>(i%<span class="number">10</span>==<span class="number">0</span>) &#123;</span><br><span class="line">						str=<span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">						<span class="type">byte</span>[]buf=str.getBytes();</span><br><span class="line">						fos.write(buf);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			fos.close();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(FileNotFoundException e1) &#123;</span><br><span class="line">			System.out.println(e1);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e2) &#123;</span><br><span class="line">			System.out.println(e2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjEyMjI3MQ==,size_16,color_FFFFFF,t_70-16954600188656.png" alt="1231231"></p>
</li>
</ul>
<h4 id="字节数组输出流（ByteArrayOutputStream）"><a href="#字节数组输出流（ByteArrayOutputStream）" class="headerlink" title="字节数组输出流（ByteArrayOutputStream）"></a>字节数组输出流（ByteArrayOutputStream）</h4><ul>
<li><p>向内存的字节数组写入数据，它也采用了适配器设计模式，把字节数组类型转换为输出流类型，使程序能对字节数组进行写操作。其构造方法为：</p>
<ul>
<li><p>ByteArrayOutputStream()：创建一个新的字节数组输出流；</p>
</li>
<li><p>ByteArrayOutputStream(int size)：创建指定大小缓冲区的字节数组输出流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		ByteArrayOutputStream baos=<span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">		String s=<span class="string">&quot;Welcome to java&quot;</span>;</span><br><span class="line">		<span class="type">byte</span>[]buf=s.getBytes();</span><br><span class="line">		baos.write(buf);</span><br><span class="line">		System.out.println(baos.toString());</span><br><span class="line">		<span class="type">byte</span>[]b=baos.toByteArray();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;b.length;i++) &#123;</span><br><span class="line">			System.out.print((<span class="type">char</span>)b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Welcome to java</span><br><span class="line">Welcome to java</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="数据输出流（DataOutputStream）"><a href="#数据输出流（DataOutputStream）" class="headerlink" title="数据输出流（DataOutputStream）"></a>数据输出流（DataOutputStream）</h4><h2 id="面向字符输入-输出流"><a href="#面向字符输入-输出流" class="headerlink" title="面向字符输入&#x2F;输出流"></a>面向字符输入&#x2F;输出流</h2><blockquote>
<p>面向字符的输入输出流类都是Reader&#x2F;Writer类的子类</p>
</blockquote>
<p>如下图：</p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjEyMjI3MQ==,size_16,color_FFFFFF,t_70-16955389035348.png" alt="123131231"></p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjEyMjI3MQ==,size_16,color_FFFFFF,t_70-169553897806310.png" alt="34636545"></p>
<blockquote>
<p>对于这两个父类来说：都是抽象类，和前面的面向字节的父类提供的方法相似，只是将基于byte的参数改为基于char</p>
</blockquote>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><blockquote>
<p>Java可以将字节流和字符流互相转换</p>
</blockquote>
<h4 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h4><ul>
<li><p>Reader类和Writer类默认在本地平台字符编码和Unicode码的转换：</p>
<ul>
<li>Reader：将输出流中的其他编码转为<strong>Unicode</strong>，再分配。</li>
<li>Writer：将内存中的Unicode码转为其他编码，再写到输出流中。</li>
</ul>
</li>
<li><p><strong>采用特定类型编码的字节流：</strong></p>
<ul>
<li><p>InputStreamReader类：将一个字节中的若干个字节解码-》字符</p>
<ul>
<li><p>构造方法有:</p>
<ul>
<li>InputStreamReader（InputStream in）：默认字符编码，将字节输入流转为<strong>字符输入流</strong>并读取数据</li>
<li>InputStreamReader（InputStream in ，Charset c）：指定编码从输入流中读取数据</li>
<li>InputStreamReader（InputStream in ,String enc）throws Exception ：指定编码，将字节输入流转为字符输入流，并读取数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		String filename=<span class="string">&quot;D:/welcome.txt&quot;</span>;        <span class="comment">//创建一个变量filename存放文件路径</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			InputStreamReader isr=<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename),<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">//创建转换输入流，按UTF-8的编码从输入流读取数据</span></span><br><span class="line">			<span class="type">int</span> c;                               <span class="comment">//创建int类型变量c</span></span><br><span class="line">			<span class="keyword">while</span>((c=isr.read())!=-<span class="number">1</span>)            <span class="comment">//使用while循环读取文件数据</span></span><br><span class="line">				System.out.print((<span class="type">char</span>)c);       <span class="comment">//输出打印字符</span></span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;                  </span><br><span class="line">			e.printStackTrace();                 <span class="comment">//查看完整错误信息</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>OutputStreamReader类：将字符-》编码成若干个字节，最后写入一个字节流。</p>
<ul>
<li><p>类比于上面的方法内容.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		String filename=<span class="string">&quot;D:/welcome.txt&quot;</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			OutputStreamWriter osw=<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filename),<span class="string">&quot;UTF-8&quot;</span>);    <span class="comment">//创建转换输出流</span></span><br><span class="line">			osw.write(<span class="string">&quot;Hello，一个想当英雄的男人！！！&quot;</span>);    <span class="comment">//向文本文件写入数据</span></span><br><span class="line">   			osw.close();                <span class="comment">//关闭文件</span></span><br><span class="line">		&#125;<span class="keyword">catch</span>(IOException e) &#123;    </span><br><span class="line">			e.printStackTrace();        <span class="comment">//查看所有错误信息</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h4><ul>
<li>往往在实际应用中：标准键盘输入&#x3D;字节；</li>
<li>当然如果想要一次性输入一行字符串，可以使用BufferedReader对字符流进行包装处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));    </span><br><span class="line">String  x=in.readLine();                <span class="comment">//读取一行字符串</span></span><br></pre></td></tr></table></figure>

<h2 id="使用区别：FileWriter—FileReader类"><a href="#使用区别：FileWriter—FileReader类" class="headerlink" title="使用区别：FileWriter—FileReader类"></a>使用区别：FileWriter—FileReader类</h2><h4 id="FileWriter："><a href="#FileWriter：" class="headerlink" title="FileWriter："></a>FileWriter：</h4><blockquote>
<p>用于<strong>写</strong>字符文件，通常将对象看成一个以字符为单位的无格式字符输出流</p>
</blockquote>
<ul>
<li><p>FileWriter(File file,boolean append)throws IOException：根据File对象构造一个FileWriterx对象，若第二个参数为true,则将字符以添加的方式写入文件尾处，若为false!则原有文件内容被清除；</p>
</li>
<li><p>FileWriter(String fileName,boolean append)throws IOException：根据字符串文件名构造一个FileWriter&gt;对象，若第二个参数为true,则将字符以添加的方式写入文件尾处，若为flse则原有文件内容被清除。</p>
<p><strong>实例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">//将九九乘法表写入文本文件中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">		String filename=<span class="string">&quot;D:/table.txt&quot;</span>;        </span><br><span class="line">		FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filename,<span class="literal">true</span>);    <span class="comment">//创建FileWriter对象</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) &#123;                         <span class="comment">//利用两个for循环打印九九乘法表</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++) &#123;</span><br><span class="line">				String s=i+<span class="string">&quot;*&quot;</span>+j+<span class="string">&quot;=&quot;</span>+j*i+<span class="string">&quot; &quot;</span>;</span><br><span class="line">				fw.write(s);                            <span class="comment">//将乘法表写入文本文件中</span></span><br><span class="line">			&#125;</span><br><span class="line">			fw.write(<span class="string">&quot;\r\n&quot;</span>);                           <span class="comment">//写入回车换行符</span></span><br><span class="line">		&#125;</span><br><span class="line">		fw.flush();                                     <span class="comment">//强制刷新流</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="FileReader："><a href="#FileReader：" class="headerlink" title="FileReader："></a>FileReader：</h4><blockquote>
<p>用于<strong>读取</strong>字符文件，将对象看成一个以字符为基本单位的无格式字符输入流</p>
</blockquote>
<ul>
<li><p>以下构造方法和上面的输出流实相似的，所以直接上实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">		FileReader fr=<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:/table.txt&quot;</span>);   <span class="comment">//创建FileReader对象</span></span><br><span class="line">		<span class="type">int</span> c;</span><br><span class="line">		<span class="keyword">while</span>((c=fr.read())!=-<span class="number">1</span>) &#123;                <span class="comment">//读取文件中的内容</span></span><br><span class="line">			System.out.print((<span class="type">char</span>)c);            <span class="comment">//将c转换为char类型并输出文件中的内容</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="常用的包装流：BufferedWriter–BufferedReader类"><a href="#常用的包装流：BufferedWriter–BufferedReader类" class="headerlink" title="常用的包装流：BufferedWriter–BufferedReader类"></a>常用的包装流：BufferedWriter–BufferedReader类</h2><h4 id="BufferedWriter："><a href="#BufferedWriter：" class="headerlink" title="BufferedWriter："></a>BufferedWriter：</h4><blockquote>
<p>是带缓冲的字符流（缓冲流），可以用以文本行为为单位处理文本。</p>
</blockquote>
<ul>
<li><p>以下是比较常用的方法：</p>
<ul>
<li><p>BufferedWriter(Vriter out):将输出流out转换成带缓冲的字符流，缓冲区大小为<strong>系统默认</strong>的：</p>
</li>
<li><p>BufferedWriter(Writer out,int sz):将流out转换成带缓冲的字符流，缓冲区大小为<strong>sz</strong>;</p>
</li>
<li><p>void newLine()throws IOException:<strong>写入行结束标记</strong>，该标记不是简单的换行符（八n’),而是由系统定义的属性Iine.separator。</p>
<p><strong>实例代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">//将100以内所有的质数写入文本文件，要求每10个数一行。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPrime</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/<span class="number">2</span>;i++)          <span class="comment">//判断是否为质数</span></span><br><span class="line">			<span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">		BufferedWriter bw=<span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D:/number.txt&quot;</span>));  <span class="comment">//创建BufferedWriter对象</span></span><br><span class="line">		<span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(isPrime(i)) &#123;</span><br><span class="line">				j++;</span><br><span class="line">				String s=String.valueOf(i);</span><br><span class="line">				String s1=s+<span class="string">&quot; &quot;</span>;</span><br><span class="line">				bw.write(s1);            <span class="comment">//写入数据到文本文件中</span></span><br><span class="line">				<span class="keyword">if</span>(j==<span class="number">10</span>) &#123;                    </span><br><span class="line">					j=<span class="number">0</span>;                 </span><br><span class="line">					bw.newLine();        <span class="comment">//当j=10时，写入一个换行符</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bw.flush();                      <span class="comment">//强制刷新流</span></span><br><span class="line">		bw.close();                      <span class="comment">//关闭文本文件</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="BufferedReader："><a href="#BufferedReader：" class="headerlink" title="BufferedReader："></a>BufferedReader：</h4><blockquote>
<p>此处也是带缓冲的字符流,可以将以文本行为为单位处理文本的场合.</p>
</blockquote>
<ul>
<li><p>常用方法和BufferedWriter的方法相似,</p>
<p><strong>实例代码:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">second</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		BufferedReader br=<span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:/number.txt&quot;</span>));    <span class="comment">//创建BufferedReader对象</span></span><br><span class="line">		<span class="type">int</span> c;                            <span class="comment">//创建int型变量c</span></span><br><span class="line">		<span class="keyword">while</span>((c=br.read())!=-<span class="number">1</span>)          <span class="comment">//判断是否读完文本中的数据</span></span><br><span class="line">			System.out.print((<span class="type">char</span>)c);    <span class="comment">//将int型转换为char型并输出</span></span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="非常好用的写入流：PrintWriter类"><a href="#非常好用的写入流：PrintWriter类" class="headerlink" title="非常好用的写入流：PrintWriter类"></a>非常好用的写入流：PrintWriter类</h2><blockquote>
<p>当需要以Java的基本数据类型为单位写入文本文件时,使用该PrintWriter类,进行此类文本的输出.</p>
</blockquote>
<ul>
<li><p>构造方法有以下几种：</p>
<ul>
<li>PrintWriter(Writer out)：将<strong>任意一个字符输出流</strong>out串接成一个PrintWriter对象，不自动刷空流：</li>
<li>PrintWriter(Writer out,<strong>boolean autoFlush</strong>)：将任意一个字符输出流out串接成一个PrintWriter对象，<strong>若boolean值为true，则自动刷空流；</strong></li>
<li>PrintWriter(OutputStream out)：将任意一个字符输出流out串接成一个PrintWriter对象，不自动刷空流；</li>
<li>PrintWriter(OutputStream out,boolean autoFlush)：将任意一个字节输出流out串接成一个PrintWriter对象，若boolean值为true，则自动刷空流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="comment">//如果一个四位数是11的倍数且十位数字加上百位数字刚好等于前位数字，则将该四位数写入文本文件中。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">printWriter</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException&#123;</span><br><span class="line">		FileWriter fw=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D:/four.txt&quot;</span>);    <span class="comment">//创建FileWriter对象</span></span><br><span class="line">		PrintWriter pw=<span class="keyword">new</span> <span class="title class_">PrintWriter</span>(fw);             <span class="comment">//创建PrintWriter对象</span></span><br><span class="line">		<span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1000</span>;i&lt;<span class="number">10000</span>;i++) &#123;                   <span class="comment">//利用for循环获得各个位的数字</span></span><br><span class="line">			<span class="type">int</span> A=i/<span class="number">1000</span>;                               <span class="comment">//千位上的数</span></span><br><span class="line">			<span class="type">int</span> B=i/<span class="number">100</span>%<span class="number">10</span>;                             <span class="comment">//百位上的数</span></span><br><span class="line">			<span class="type">int</span> C=i/<span class="number">10</span>%<span class="number">10</span>;                              <span class="comment">//十位上的数</span></span><br><span class="line">			<span class="keyword">if</span>(i%<span class="number">11</span>==<span class="number">0</span>&amp;&amp;A==B+C) &#123;                       <span class="comment">//如果是11的倍数，且十位数字加百位数字等于千位数字</span></span><br><span class="line">				pw.print(i+<span class="string">&quot;  &quot;</span>);                       <span class="comment">//打印输出该四位数</span></span><br><span class="line">				<span class="keyword">if</span>(++num==<span class="number">10</span>) &#123;                         <span class="comment">//每十个数换一行</span></span><br><span class="line">					num=<span class="number">0</span>;</span><br><span class="line">					pw.println();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		fw.close();                                     <span class="comment">//关闭文本文件</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Linux回顾"><a href="#Linux回顾" class="headerlink" title="Linux回顾"></a>Linux回顾</h1><hr>
<h2 id="查找可执行文件的指令"><a href="#查找可执行文件的指令" class="headerlink" title="查找可执行文件的指令"></a>查找可执行文件的指令</h2><h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><ul>
<li>用于定位指令的二进制程序,源代码文件和man手册页等相关文件的路径.</li>
<li>whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（-b),man说明文件（-m），源代码文件（-s）</li>
</ul>
<h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><ul>
<li>locate和slocate命令都是用于查找文件或目录</li>
<li>locate其实是find -name的另一种写法，但是比后者搜索快，（原因locate不搜索具体目录）</li>
<li>注意：在使用前，使用updatedb命令，手动更新Linux数据库，在使用locate指令</li>
</ul>
<h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><ul>
<li>which命令用于查找并显示给定命令的绝对路径</li>
<li>环境变量PATH中保存查找命令的目录，which指令会在其寻找相应的符合条件的文件。</li>
</ul>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><ul>
<li><p>type命令用来显示指定命令的类型，判断给出的指令是内部还是外部指令。</p>
</li>
<li><p>命令类型：alias：别名；keyword、function、builtin：关键字，，函数，内建命令，Shell函数保留字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-t：输出“file”、“alias”或者“builtin”，分别表示给定的指令为“外部指令”、“命令别名”或者“内部指令”；</span><br><span class="line">-p：如果给出的指令为外部指令，则显示其绝对路径；</span><br><span class="line">-a：在环境变量“PATH”指定的路径中，显示给定指令的信息，包括命令别名。</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# type date date is /bin/date [root@localhost ~]# type mysql mysql is /usr/bin/mysql</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><ul>
<li>find命令用来在指定目录下寻找文件</li>
<li>如果使用该命令时,不设置任何参数,则find命令会在当前目录下查找子目录与文件.。</li>
</ul>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><hr>
<h2 id="多线程–守护线程和非守护线程"><a href="#多线程–守护线程和非守护线程" class="headerlink" title="多线程–守护线程和非守护线程"></a>多线程–守护线程和非守护线程</h2><h4 id="守护线程："><a href="#守护线程：" class="headerlink" title="守护线程："></a>守护线程：</h4><ul>
<li>和<strong>main</strong>相关的，用户线程，用户自己创建的线程，如果主线程停止，不会影响用户线程。</li>
<li><strong>GC线程</strong>（线程不定时回收垃圾）</li>
<li>特征：和主线程一起销毁。</li>
</ul>
<h4 id="非守护线程："><a href="#非守护线程：" class="headerlink" title="非守护线程："></a>非守护线程：</h4><ul>
<li>其实就是<strong>用户线程</strong></li>
<li>特征：和主线程互不影响。</li>
</ul>
<blockquote>
<p>其实：当所有的非守护线程结束时，程序就终止了，同时也会终止<strong>进程中</strong>所有的守护线程。</p>
</blockquote>
<p>如下图：<img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTc3ODM4,size_16,color_FFFFFF,t_70.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XUg5lPDg-1587784231713)(C:\Users\闫晓龙\AppData\Roaming\Typora\typora-user-images\image-20200425110023694.png)]"></p>
<h4 id="实例代码："><a href="#实例代码：" class="headerlink" title="实例代码："></a>实例代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">thread.setDaemon(<span class="literal">true</span>);  <span class="comment">//设置为守护线程</span></span><br><span class="line"></span><br><span class="line">代码如下 ：</span><br><span class="line"><span class="keyword">package</span> com.briup.demo.ThreadTest;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">		Threadthread <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span>&#123;</span><br><span class="line">						Thread.sleep(millis:<span class="number">100</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">						System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">					System.out.println(<span class="string">&quot;我是子线程.·.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		thread.setDaemon (<span class="literal">true</span>);  <span class="comment">//设置为守护线程</span></span><br><span class="line">		thread.start();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;我是主线程&quot;</span>)；</span><br><span class="line">        &#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;主线程执行完毕！&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul>
<li>setDaemon（true）必须要在调用线程的start（）方法之前设置，否则会抛出异常。</li>
<li>在守护线程中产生的新线程也是守护线程。</li>
<li>不是所有的应用都可以分配守护线程，比如：读写操作或者计算机逻辑。</li>
</ul>
<h4 id="自定义守护线程"><a href="#自定义守护线程" class="headerlink" title="自定义守护线程"></a>自定义守护线程</h4><p>当然除去JVM内部的守护线程外，用户可以自定义：</p>
<ul>
<li><pre><code class="Java">//自定义:
public final void setDaemon(boolean on)

//可以通过方法查询该线程是否为守护线程
public final boolean isDaemon()

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># MyBatis常见问题</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 针对于mybatis缓存</span><br><span class="line"></span><br><span class="line">### 缓存理解</span><br><span class="line"></span><br><span class="line">&gt; 缓存的概念：存在内存中的临时资源。</span><br><span class="line"></span><br><span class="line">- 将用户经常查询的数据存放在内存中，当用户去查询数据的时候就不用去磁盘（关系型数据库文件）查；从而可以从缓存中查询，提高查询效率。</span><br><span class="line"></span><br><span class="line">&gt; 为什么使用缓存？</span><br><span class="line"></span><br><span class="line">- 减少和数据库的连接交互，减少系统开销，提高系统效率。</span><br><span class="line"></span><br><span class="line">&gt; 缓存适合什么样的数据？</span><br><span class="line"></span><br><span class="line">- 经常查询的，而且很少改变的数据。</span><br><span class="line"></span><br><span class="line">&gt; 缓存原理</span><br><span class="line"></span><br><span class="line">![img](../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/2053539-20201029112923376-360860914.png)</span><br><span class="line"></span><br><span class="line">### **MyBatis系统中默认定义两种缓存：**</span><br><span class="line"></span><br><span class="line">#### 一级缓存：</span><br><span class="line"></span><br><span class="line">- 默认开启，（SqlSession级别：称为本地缓存）</span><br><span class="line"></span><br><span class="line">#### 二级缓存（全局缓存）：</span><br><span class="line"></span><br><span class="line">- 需要手动设置，基于namespace 命名空间级别</span><br><span class="line"></span><br><span class="line">- 设置全局缓存：![img](../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/2053539-20201029105134449-1597163409.png)</span><br><span class="line"></span><br><span class="line">- ```xml</span><br><span class="line">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">  &lt;!DOCTYPE mapper</span><br><span class="line">          PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">          &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">  &lt;mapper namespace=&quot;com.king.dao.UserMapper&quot;&gt;</span><br><span class="line">      &lt;!--在当前Mapper.xml中使用二级缓存--&gt;</span><br><span class="line">      &lt;cache  eviction=&quot;FIFO&quot;</span><br><span class="line">              flushInterval=&quot;60000&quot;</span><br><span class="line">              size=&quot;512&quot;</span><br><span class="line">              readOnly=&quot;true&quot;/&gt;</span><br><span class="line">      &lt;select id=&quot;queryUserById&quot;  resultType=&quot;user&quot;&gt;</span><br><span class="line">          select * from mybatis.user WHERE id=#&#123;id&#125;</span><br><span class="line">      &lt;/select&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li><p>当然，也有自定义接口，通过实现Cache接口来实现</p>
</li>
</ul>
<blockquote>
<p>注意实体类的规范性</p>
</blockquote>
<h4 id="针对于实体类的缓存设置-需要该类实现序列化"><a href="#针对于实体类的缓存设置-需要该类实现序列化" class="headerlink" title="针对于实体类的缓存设置:需要该类实现序列化."></a>针对于实体类的缓存设置:需要该类实现序列化.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>二级缓存的细节部分:</p>
<ol>
<li>只要开启了二级缓存，在同一个Mapper下就有效</li>
<li>所有的数据都会先放在一级缓存中；</li>
<li>只有当会话提交，或者关闭的时候，才会提交到二级缓冲中</li>
</ol>
</blockquote>
<h2 id="在Mybatis中乐观锁和悲观锁是什么，如何应用？"><a href="#在Mybatis中乐观锁和悲观锁是什么，如何应用？" class="headerlink" title="在Mybatis中乐观锁和悲观锁是什么，如何应用？"></a>在Mybatis中乐观锁和悲观锁是什么，如何应用？</h2><blockquote>
<p>什么是乐观锁？</p>
</blockquote>
<p><strong>乐观锁总是假设最好的情况，</strong>认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只有在提交修改的时候去验证对应资源（也就是数据）是否被其他线程修改了（具体方法可以使用版本号机制或者CAS算法处理）。</p>
<blockquote>
<p>什么是悲观锁？</p>
</blockquote>
<p><strong>悲观锁总是假设最坏的情况，</strong>认为共享资源每次被访问的时候就会出现问题（比如共享数据被修改），所以每次获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程。</strong></p>
<blockquote>
<p><strong>二者在处理高并发的情况下，又有什么差异？</strong></p>
</blockquote>
<ul>
<li>悲观锁：<ul>
<li>锁竞争激烈可能胡线程阻塞，增加系统开销，并且还可能存在死锁问题。</li>
<li>（理论上多用与写比较多的场景）<strong>多写场景，竞争激烈</strong></li>
<li><strong>开销固定</strong></li>
</ul>
</li>
<li>乐观锁：<ul>
<li>相对于悲观锁来说，不存在线程阻塞和死锁问题；但如果冲突频繁（写多的时候）会频繁失败和重试。</li>
<li>（多用于写比较少的场景）多读场景，竞争较少</li>
<li><strong>针对的对象是单个共享变量</strong></li>
</ul>
</li>
</ul>
<h2 id="什么是数据持久化？"><a href="#什么是数据持久化？" class="headerlink" title="什么是数据持久化？"></a>什么是数据持久化？</h2><p>数据持久化是将内存中的数据模型转换为存储模型，以及将存储模型转换为内存的数据模型的统称。</p>
<p>例如：<strong>文件的存储、数据的读取</strong>就是数据持久化操作。</p>
<p>我们编写应用程序操作数据库，<strong>对表数据进行增删改查</strong>的操作的时候就是数据持久化的操作。</p>
<h2 id="MyBatis框架简介"><a href="#MyBatis框架简介" class="headerlink" title="MyBatis框架简介"></a><strong>MyBatis框架简介</strong></h2><ul>
<li>MyBatis框架是一个<strong>开源的数据持久层</strong>框架</li>
<li>MyBatis的<strong>内部封装JDBC访问数据库</strong>的操作，可以支持普通的SQL查询、存储过程和高级映射。</li>
<li>MyBatis作为持久层框架，主要的思想：将程序中的大量SQL语句剥离出来，实现<strong>SQL的灵活配置</strong>。</li>
<li>好处：将SQL与程序代码分离。</li>
</ul>
<h2 id="什么是ORM？"><a href="#什么是ORM？" class="headerlink" title="什么是ORM？"></a>什么是ORM？</h2><p>ORM是对象关系映射，是一种数据持久化技术。它在对象模型和关系数据库直接建立起对应关系，</p>
<p>（实际：通过JavaBean对象去操作数据库表的数据）。</p>
<p>MyBatis通过<strong>简单的XML或注解的方式</strong>进行配置和原始映射，是一种<strong>半自动的ORM</strong>实现</p>
<h2 id="MyBatis的优缺点和使用场景"><a href="#MyBatis的优缺点和使用场景" class="headerlink" title="MyBatis的优缺点和使用场景"></a>MyBatis的优缺点和使用场景</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>减少JDBC的代码量、简单易学的框架</li>
<li>提交XML标签，支持编写<strong>动态的SQL</strong>，可以满足不同的业务需求</li>
<li>提供映射标签，支持<strong>对象与数据库的ORM字段关系映射</strong>。</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>SQL语句的编写工作量比较大，对开发人员编写SQL语句有一定的要求</li>
<li>SQL语句依赖于数据库，导致数据库<strong>不具有好的移植性</strong>，不可以随便更换数据库。</li>
</ul>
<h3 id="适合场景："><a href="#适合场景：" class="headerlink" title="适合场景："></a>适合场景：</h3><ul>
<li>MyBatis专注于SQL自身，是一个足够灵活的DAO层解决方案。<strong>解决对性能的要求很高</strong>。</li>
</ul>
<h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><ul>
<li><strong>#{}是预编译处理</strong>，${}是字符串替换。</li>
<li>MyBatis在处理#{}时，<strong>会将SQL中的#{}替换为“？”号</strong>，调用PrepareStatement的set方法来赋值。</li>
<li>MyBatis在处理${}时，替换成变量的值</li>
<li><strong>使用#{}可以有效防止SQL注入，提高系统安全性。</strong></li>
</ul>
<h2 id="当实体类中的属性名和表中的字段名不一样，怎么处理呢？"><a href="#当实体类中的属性名和表中的字段名不一样，怎么处理呢？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样，怎么处理呢？"></a>当实体类中的属性名和表中的字段名不一样，怎么处理呢？</h2><ul>
<li>第一种处理方式：通过在查询的SQL语句中定义字段名的别名，让<strong>字段名的别名和实体类的属性名</strong>一致</li>
<li>第二种处理方式：<strong>通过&#96;&#96;映射</strong>字段名和实体类属性名的一一对应的关系。</li>
</ul>
<h1 id="HashMap常见问题"><a href="#HashMap常见问题" class="headerlink" title="HashMap常见问题"></a>HashMap常见问题</h1><hr>
<h4 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h4><ul>
<li><strong>Hash表结构</strong>（链表散列：<strong>数组+链表</strong>）实现，结合数组和链表的优点。<strong>当链表长度超过8时，链表转为红黑树</strong>。</li>
</ul>
<h4 id="2、HashMap的工作原理"><a href="#2、HashMap的工作原理" class="headerlink" title="2、HashMap的工作原理"></a>2、HashMap的工作原理</h4><ul>
<li><p>底层是Hash数组和单向链表，数组中每个元素是链表。</p>
</li>
<li><p>由Node内部类（实现Map.Entry&lt;K,V&gt;接口）实现。</p>
</li>
<li><p>HashMap运用：</p>
<ul>
<li><p>put方法：存储对象时 ，将kv键值对传给put方法。</p>
<ul>
<li>针对于JDK1.7之前使用头插法、JDK1.8使用尾插法（链表）</li>
</ul>
<blockquote>
<p>注意：当碰撞导致链表长度大于8时，链表转换为红黑树。</p>
</blockquote>
<ul>
<li>实现细节：<ul>
<li>1、利用Hash计算Hash值，2、调整数组大小（扩容之类）</li>
<li>步骤3：<ul>
<li>如果k的<strong>Hash值</strong>在HashMap中不存在，插入值；<strong>存在，碰撞</strong></li>
<li>如果存在，且两者的**.equals方法<strong>返回值true，</strong>更新键值**</li>
<li>如果存在，但是返回值为false，则插入<strong>链表尾部</strong>或者<strong>红黑树中</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>get方法：获取对象时，将K传给get方法。</p>
<ul>
<li><strong>hashcode</strong>是定位的，<strong>存储位置</strong>；</li>
<li>equals方法是定性的，比较两者是否相等。</li>
<li>实现：<ul>
<li>调用Hash计算Hash值，获取该键值所在的<strong>链表的数组下标</strong></li>
<li>顺序遍历链表，equals方法查找Node链表中<strong>K所对应的V</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3、当两个对象的hashcode相同会发生什么？"><a href="#3、当两个对象的hashcode相同会发生什么？" class="headerlink" title="3、当两个对象的hashcode相同会发生什么？"></a>3、当两个对象的hashcode相同会发生什么？</h4><ul>
<li>因为hashcode相同，不一定就是相等（equals方法比较值）；这时两个对象的<strong>数组下标一样</strong>，此时会发生”<strong>碰撞</strong>“。</li>
<li>因为HashMap使用链表存储对象，这个Node会存储到链表中。</li>
</ul>
<h4 id="4、你知道Hash的实现吗？为什么要这么实现呢？"><a href="#4、你知道Hash的实现吗？为什么要这么实现呢？" class="headerlink" title="4、你知道Hash的实现吗？为什么要这么实现呢？"></a>4、你知道Hash的实现吗？为什么要这么实现呢？</h4><ul>
<li>在JDK1.8中，通过hashcode的<strong>高16位异或低16位</strong>实现的；</li>
<li>主要从速度、功效和质量来考虑：<strong>减少系统的开销</strong>，也不会造成因为高位木参与下标的计算从而发生“碰撞”</li>
</ul>
<h4 id="5、为什么要用异或运算符？"><a href="#5、为什么要用异或运算符？" class="headerlink" title="5、为什么要用异或运算符？"></a>5、为什么要用异或运算符？</h4><ul>
<li><strong>保证了对象的hashcode的32位值</strong>，只要有一位发生改变，整个Hash（）方法返回值也改变，<strong>尽可能减少碰撞</strong></li>
</ul>
<h4 id="6、HashMap的table的容量如何确定？"><a href="#6、HashMap的table的容量如何确定？" class="headerlink" title="6、HashMap的table的容量如何确定？"></a>6、HashMap的table的容量如何确定？</h4><ul>
<li>table数组大小：由capacity参数决定，默认是16，也可以构造时传入，最大限制1&lt;&lt;30;</li>
</ul>
<h4 id="7、loadFactor是什么？该容量如何变化？这个变化会带来什么问题？"><a href="#7、loadFactor是什么？该容量如何变化？这个变化会带来什么问题？" class="headerlink" title="7、loadFactor是什么？该容量如何变化？这个变化会带来什么问题？"></a>7、loadFactor是什么？该容量如何变化？这个变化会带来什么问题？</h4><h5 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h5><ul>
<li><strong>loadFactor：装载因子</strong>，</li>
<li>作用：确定table数组是否动态扩容，<strong>默认值0.75，</strong></li>
<li>例子：当table数组为16，loadFactor为0.75时，<strong>threshold就是12</strong>，当超过12时，<strong>数组动态扩容。</strong></li>
</ul>
<h5 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h5><ul>
<li>扩容时，调用<strong>resize（）方法</strong>，将table长度变为原来的两倍</li>
</ul>
<h5 id="问题三："><a href="#问题三：" class="headerlink" title="问题三："></a>问题三：</h5><ul>
<li>当数据量很大时，扩展会带来<strong>性能的损失</strong>。</li>
</ul>
<h4 id="8、说说你对红黑树的见解？"><a href="#8、说说你对红黑树的见解？" class="headerlink" title="8、说说你对红黑树的见解？"></a>8、说说你对红黑树的见解？</h4><ul>
<li>每个节点非红即黑</li>
<li>根节点总是黑色的</li>
<li>如果节点是红色的，则它的子节点必须是黑色的</li>
<li>每一个叶子节点都是黑色的空节点</li>
<li>从根节点到叶子结点或者空子节点的每条路径，必须包含相同数目的黑色节点（相同的黑色高度）</li>
</ul>
<h4 id="9、HashMap、linkedHashMap、treeMap的区别？"><a href="#9、HashMap、linkedHashMap、treeMap的区别？" class="headerlink" title="9、HashMap、linkedHashMap、treeMap的区别？"></a>9、HashMap、linkedHashMap、treeMap的区别？</h4><ul>
<li>linkedHashMap：保存记录插入的位置，用Iterator遍历时，先取到的记录肯定是先插入的，遍历比HashMap慢。</li>
<li>treeMap：实现SortMap接口，能够把它保存的记录根据键排序（默认升序）</li>
</ul>
<h4 id="10、HashMap、linkedHashMap、treeMap使用场景？"><a href="#10、HashMap、linkedHashMap、treeMap使用场景？" class="headerlink" title="10、HashMap、linkedHashMap、treeMap使用场景？"></a>10、HashMap、linkedHashMap、treeMap使用场景？</h4><blockquote>
<p>一般情况下，HashMap用最多</p>
</blockquote>
<ul>
<li>HashMap：在Map中插入、删除、和定位元素时</li>
<li>linkedHashMap：当输入顺序和输出顺序一致的情况下</li>
<li>treeMap：需要按自然顺序或自定义顺序遍历键的情况</li>
</ul>
<h4 id="11、区别：HashMap—HashTable"><a href="#11、区别：HashMap—HashTable" class="headerlink" title="11、区别：HashMap—HashTable"></a>11、区别：HashMap—HashTable</h4><ul>
<li><strong>线程安全：</strong>HashTable；线程不安全：HashMap</li>
<li><strong>效率：</strong>HashTable&lt;HashMap</li>
<li><strong>键值对：</strong>HashMap最多只允许一个键&#x3D;null，多个值&#x3D;null；HashTable不允许；</li>
<li><strong>初始化和扩容：</strong>HashMap初始化数组为16，<strong>HashTable为11</strong><ul>
<li>扩容时：前者扩大两倍，后者扩大三倍</li>
</ul>
</li>
<li>HashMap每次重新计算Hash值；HashTable直接使用对象hashcode</li>
</ul>
<h4 id="12、HashMap的不安全体现在哪里？"><a href="#12、HashMap的不安全体现在哪里？" class="headerlink" title="12、HashMap的不安全体现在哪里？"></a>12、HashMap的不安全体现在哪里？</h4><p><strong>主要体现：</strong></p>
<ul>
<li>在JDK1.7中，多线程环境下，扩容时会造成<strong>环形链</strong>或者<strong>数据丢失</strong></li>
<li>JDK1.8中，多线程环境下，会发生<strong>数据覆盖</strong>的情况</li>
</ul>
<h4 id="13、HashMap怎样解决Hash冲突？"><a href="#13、HashMap怎样解决Hash冲突？" class="headerlink" title="13、HashMap怎样解决Hash冲突？"></a>13、HashMap怎样解决Hash冲突？</h4><ul>
<li>使用<strong>链地址法（散列表）</strong>来连接拥有相同Hash值的数据</li>
<li>使用2次扰动函数（<strong>Hash函数</strong>）来降低哈希冲突的概率，使得<strong>数据分布更平均</strong></li>
<li>引入<strong>红黑树</strong>进一步<strong>降低</strong>遍历的<strong>时间复杂度</strong>。</li>
</ul>
<h4 id="14、HashMap和ConcurrentHashMap的区别？"><a href="#14、HashMap和ConcurrentHashMap的区别？" class="headerlink" title="14、HashMap和ConcurrentHashMap的区别？"></a>14、HashMap和ConcurrentHashMap的区别？</h4><ul>
<li>后者是<strong>加锁</strong>的</li>
<li>HashMap的键值对允许有null，后者是<strong>kv都不能为null。</strong></li>
</ul>
<h1 id="Java基础常见面试回顾"><a href="#Java基础常见面试回顾" class="headerlink" title="Java基础常见面试回顾"></a>Java基础常见面试回顾</h1><hr>
<h2 id="Java常见面试题（上）"><a href="#Java常见面试题（上）" class="headerlink" title="Java常见面试题（上）"></a>Java常见面试题（上）</h2><h3 id="基础概念和常识"><a href="#基础概念和常识" class="headerlink" title="基础概念和常识"></a>基础概念和常识</h3><h4 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h4><ul>
<li><p>简单易学；<strong>面向对象（封装、继承、多态）</strong>；跨平台；</p>
</li>
<li><p>支持多线程；可靠性（具备异常处理和<strong>自动内存回收</strong>）；</p>
</li>
<li><p>安全性（提供多种安全防护机制，如访问权限修饰符等）；</p>
</li>
<li><p>高效性（just in time编译器优化处理）；</p>
</li>
<li><p>支持网络编程；<strong>编译和解释并存</strong>；</p>
</li>
</ul>
<h4 id="Java-SE-vs-Java-EE"><a href="#Java-SE-vs-Java-EE" class="headerlink" title="Java SE vs Java EE"></a>Java SE vs Java EE</h4><ul>
<li>Java SE是Java的<strong>基础版本</strong>，适合开发<strong>桌面应用程序</strong>||简单的服务器应用程序；</li>
<li><strong>Java EE</strong>是Java的高级版本，适合开发复杂的企业级应用程序||<strong>Web应用程序</strong>。</li>
</ul>
<h4 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h4><ul>
<li>JVM<ul>
<li>是运行<strong>Java字节码</strong>的虚拟机。</li>
<li>“一次编译，到处运行”关键：字节码文件和不同系统的JVM实现。</li>
</ul>
</li>
<li>JRE<ul>
<li>是Java运行时环境，包含有<strong>JVM、Java基础类库（class library）</strong></li>
</ul>
</li>
<li>JDK<ul>
<li>包含JRE、同时也含有javac、javadoc等工具，</li>
<li>用于 Java应用程序的开发和调试。</li>
</ul>
</li>
</ul>
<h4 id="什么是字节码？采用它的好处是什么？"><a href="#什么是字节码？采用它的好处是什么？" class="headerlink" title="什么是字节码？采用它的好处是什么？"></a>什么是字节码？采用它的好处是什么？</h4><ul>
<li><p>字节码</p>
<ul>
<li>在Java中，JVM可以理解的代码就是字节码文件（.class文件），</li>
<li>它不面向任何特定处理器，<strong>只面向虚拟机。</strong></li>
<li><strong>在一定程度上解决传统语言执行效率低，也保留解释性语言的可移植的特点。</strong></li>
</ul>
<p>字节码处理的视图：</p>
<p>​	<img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/java-code-to-machine-code-with-jit.png" alt="Java程序转变为机器代码的过程"></p>
<blockquote>
<p><strong>HOtSpot采用惰性评估</strong>；根据<strong>二八定律</strong>，消耗大部分系统资源的只有一小部分代码（<strong>热点代码</strong>），JIT所编译就是这部分。JVM会根据代码每次执行的情况做出优化。</p>
</blockquote>
</li>
<li><p>下面是JDK、JRE、JVM、JIT的结构：</p>
<p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/jdk-jre-jvm-jit.png" alt="JDK、JRE、JVM、JIT 这四者的关系"></p>
</li>
</ul>
<h4 id="为什么说Java语言“编译与解释并存”？"><a href="#为什么说Java语言“编译与解释并存”？" class="headerlink" title="为什么说Java语言“编译与解释并存”？"></a>为什么说Java语言“编译与解释并存”？</h4><ul>
<li>高级编程语言<ul>
<li>编译型<ul>
<li>通过编译器一次性翻译成机器码</li>
<li><strong>特点：执行速度快，开发效率低</strong></li>
</ul>
</li>
<li>解释型<ul>
<li>通过解释器一句一句的将代码解释为机器码</li>
<li>特点：<strong>执行速度慢，开发效率高</strong></li>
</ul>
</li>
</ul>
</li>
<li>步骤过程：由Java编写的程序先经过编译-》字节码文件（.class）-》Java解释器执行</li>
</ul>
<h4 id="AOT有什么优点？为什么不全部使用AOT呢？"><a href="#AOT有什么优点？为什么不全部使用AOT呢？" class="headerlink" title="AOT有什么优点？为什么不全部使用AOT呢？"></a>AOT有什么优点？为什么不全部使用AOT呢？</h4><ul>
<li>AOT：<ul>
<li>是JDK9中新的编译模式AOT，</li>
<li>和JIT的区别在于：Java程序被<strong>执行前</strong>就将其编译成机器码，属于<strong>静态编译</strong>（C、C++、GO等）</li>
<li>主要优势在于：启动时间短、内存占用少、增强Java的程序安全性。</li>
<li>使用场景：云原生</li>
</ul>
</li>
<li>原因：<ul>
<li>AOT编译器不支持Java的一些动态特性（如<strong>反射、动态代理、动态加载、JNI</strong>《Java Native Interface》）</li>
<li>根据这些特性，一些框架和库也不能用（<strong>Spring 、CGLIB</strong>）</li>
<li>所以选择使用<strong>JIT即时编译器</strong></li>
</ul>
</li>
</ul>
<h4 id="Oracle-JDK-vs-Open-JDK"><a href="#Oracle-JDK-vs-Open-JDK" class="headerlink" title="Oracle JDK vs Open JDK"></a>Oracle JDK vs Open JDK</h4><ul>
<li>区别<ul>
<li><strong>是否开源：</strong>Open JDK完全开源；Oracle JDK是基于Open JDK实现的，不完全开源。</li>
<li><strong>是否免费：</strong>Oracle JDK有免费版本，但是有时间限制；Open JDK完全free</li>
<li><strong>功能性：</strong>Oracle JDK在Open JDK基础添加新功能：JFR、JMC等</li>
<li><strong>稳定性：</strong>Open JDK不提供LTS服务，Oracle JDK每三年提供一次</li>
<li><strong>协议：</strong>Oracle JDK使用BCL&#x2F;OTN协议，而Open JDK使用GPL v2许可</li>
</ul>
</li>
</ul>
<h4 id="Java和C-的区别？"><a href="#Java和C-的区别？" class="headerlink" title="&#x3D;&#x3D;Java和C++的区别？&#x3D;&#x3D;"></a>&#x3D;&#x3D;Java和C++的区别？&#x3D;&#x3D;</h4><ul>
<li><blockquote>
<p>Java和C++都是面向对象（封装、继承、多态）</p>
</blockquote>
</li>
<li><p>区别</p>
<ul>
<li>Java<strong>不提供指针</strong>来直接访问内存，程序<strong>内存更加安全</strong></li>
<li>Java的类是单继承，<strong>C++支持多继承</strong>；但是Java的接口可以多继承。</li>
<li>Java有自动内存管理垃圾回收机制（<strong>GC</strong>），不用手动释放内存</li>
<li><strong>C++同时支持方法重载和操作符重载</strong>；Java只支持方法重载（设计思想不同）</li>
</ul>
</li>
</ul>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p><img src="/../images/%E9%9D%A2%E8%AF%95%E6%95%B4%E5%90%88%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/image-20231010152847331.png" alt="image-20231010152847331"></p>
<h2 id="Java常见面试题（中）"><a href="#Java常见面试题（中）" class="headerlink" title="Java常见面试题（中）"></a>Java常见面试题（中）</h2><h2 id="Java常见面试题（下）"><a href="#Java常见面试题（下）" class="headerlink" title="Java常见面试题（下）"></a>Java常见面试题（下）</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">6wensitan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/post/62089d08.html">http://example.com/post/62089d08.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Green Park</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%B7%E9%A2%98%E5%9B%9E%E9%A1%BE/">刷题回顾</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.pixabay.com/photo/2023/08/23/12/57/young-8208513_640.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/fd3a8eda.html" title="Mybatis（短期更新）"><img class="cover" src="https://cdn.pixabay.com/photo/2023/09/05/12/29/boy-8235025_640.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mybatis（短期更新）</div></div></a></div><div class="next-post pull-right"><a href="/post/e28311eb.html" title="图解网络（基础）"><img class="cover" src="https://cdn.pixabay.com/photo/2023/07/19/22/28/amur-tiger-8138017_640.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">图解网络（基础）</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.</span> <span class="toc-text">回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%9E%90Java%E4%B8%ADvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">浅析Java中volatile关键字及其作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.0.1.</span> <span class="toc-text">进程和线程的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E5%88%9B%E5%BB%BA%EF%BC%89"><span class="toc-number">1.1.1.0.2.</span> <span class="toc-text">线程的两种方式（创建）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.1.0.3.</span> <span class="toc-text">生命周期</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JVM-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.2.0.1.</span> <span class="toc-text">JVM 的概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#JVM%E7%9A%84%E7%BB%93%E6%9E%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">1.1.2.0.2.</span> <span class="toc-text">JVM的结构组成部分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">volatile关键字作用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%88%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%89"><span class="toc-number">1.1.3.0.1.</span> <span class="toc-text">内存可见性（不能保证变量的原子性）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="toc-number">1.1.3.0.2.</span> <span class="toc-text">禁止指令重排</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E6%9C%AC%E8%8A%82%E5%86%85%E5%AE%B9%E7%9A%84%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">1.1.4.</span> <span class="toc-text">对于本节内容的总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%93%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.</span> <span class="toc-text">数据结构–二叉树的先中后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">二叉树的递归特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">三种遍历方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.3.0.1.</span> <span class="toc-text">先序遍历代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.3.0.2.</span> <span class="toc-text">中序遍历代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.3.0.3.</span> <span class="toc-text">后序遍历代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-%E6%B1%82%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-number">1.2.3.0.4.</span> <span class="toc-text">应用:求树的深度</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.</span> <span class="toc-text">区别时间复杂度和空间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.0.1.</span> <span class="toc-text">时间复杂度:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.0.1.0.1.</span> <span class="toc-text">如何理解时间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.0.1.0.2.</span> <span class="toc-text">如何计算时间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.0.1.0.3.</span> <span class="toc-text">常见的几种时间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%A5%BD-%E6%9C%80%E5%9D%8F-%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.0.1.0.4.</span> <span class="toc-text">最好\最坏\平均时间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="toc-number">2.0.2.</span> <span class="toc-text">空间复杂度：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.0.2.0.1.</span> <span class="toc-text">如何理解空间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="toc-number">2.0.2.0.2.</span> <span class="toc-text">常见空间复杂度：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A4%E5%88%ABJava-IO%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.</span> <span class="toc-text">判别Java IO流的使用区别，以及使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">3.1.</span> <span class="toc-text">面向字节输入&#x2F;输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E7%9A%84%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">3.1.1.</span> <span class="toc-text">面向字节的输入流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%88FileInputStream%EF%BC%89"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">文件输入流（FileInputStream）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%88ByteArraryInputStream%EF%BC%89"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">字节数组输入流（ByteArraryInputStream）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E6%B5%81%EF%BC%88DataInputStream%EF%BC%89"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">数据输入流（DataInputStream）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E7%9A%84%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">3.1.2.</span> <span class="toc-text">面向字节的输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88FileOutputStream%EF%BC%89"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">文件输出流（FileOutputStream）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88ByteArrayOutputStream%EF%BC%89"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">字节数组输出流（ByteArrayOutputStream）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88DataOutputStream%EF%BC%89"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">数据输出流（DataOutputStream）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">3.2.</span> <span class="toc-text">面向字符输入&#x2F;输出流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">3.3.</span> <span class="toc-text">转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.3.0.1.</span> <span class="toc-text">编码格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8"><span class="toc-number">3.3.0.2.</span> <span class="toc-text">实际使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB%EF%BC%9AFileWriter%E2%80%94FileReader%E7%B1%BB"><span class="toc-number">3.4.</span> <span class="toc-text">使用区别：FileWriter—FileReader类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FileWriter%EF%BC%9A"><span class="toc-number">3.4.0.1.</span> <span class="toc-text">FileWriter：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileReader%EF%BC%9A"><span class="toc-number">3.4.0.2.</span> <span class="toc-text">FileReader：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8C%85%E8%A3%85%E6%B5%81%EF%BC%9ABufferedWriter%E2%80%93BufferedReader%E7%B1%BB"><span class="toc-number">3.5.</span> <span class="toc-text">常用的包装流：BufferedWriter–BufferedReader类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedWriter%EF%BC%9A"><span class="toc-number">3.5.0.1.</span> <span class="toc-text">BufferedWriter：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BufferedReader%EF%BC%9A"><span class="toc-number">3.5.0.2.</span> <span class="toc-text">BufferedReader：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%94%A8%E7%9A%84%E5%86%99%E5%85%A5%E6%B5%81%EF%BC%9APrintWriter%E7%B1%BB"><span class="toc-number">3.6.</span> <span class="toc-text">非常好用的写入流：PrintWriter类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E5%9B%9E%E9%A1%BE"><span class="toc-number">4.</span> <span class="toc-text">Linux回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text">查找可执行文件的指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#whereis"><span class="toc-number">4.1.0.1.</span> <span class="toc-text">whereis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#locate"><span class="toc-number">4.1.0.2.</span> <span class="toc-text">locate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#which"><span class="toc-number">4.1.0.3.</span> <span class="toc-text">which</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#type"><span class="toc-number">4.1.0.4.</span> <span class="toc-text">type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find"><span class="toc-number">4.1.0.5.</span> <span class="toc-text">find</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E2%80%93%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">多线程–守护线程和非守护线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="toc-number">5.1.0.1.</span> <span class="toc-text">守护线程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="toc-number">5.1.0.2.</span> <span class="toc-text">非守护线程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">5.1.0.3.</span> <span class="toc-text">实例代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">5.1.0.4.</span> <span class="toc-text">注意事项：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.1.0.5.</span> <span class="toc-text">自定义守护线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E4%BA%8E%E5%AE%9E%E4%BD%93%E7%B1%BB%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%BE%E7%BD%AE-%E9%9C%80%E8%A6%81%E8%AF%A5%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">5.1.0.6.</span> <span class="toc-text">针对于实体类的缓存设置:需要该类实现序列化.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Mybatis%E4%B8%AD%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">在Mybatis中乐观锁和悲观锁是什么，如何应用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">什么是数据持久化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B"><span class="toc-number">5.4.</span> <span class="toc-text">MyBatis框架简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFORM%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">什么是ORM？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MyBatis%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.6.</span> <span class="toc-text">MyBatis的优缺点和使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">5.6.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">5.6.2.</span> <span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E5%90%88%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">5.6.3.</span> <span class="toc-text">适合场景：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.7.</span> <span class="toc-text">#{}和${}的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%91%A2%EF%BC%9F"><span class="toc-number">5.8.</span> <span class="toc-text">当实体类中的属性名和表中的字段名不一样，怎么处理呢？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">HashMap常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.0.0.1.</span> <span class="toc-text">1、数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81HashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">6.0.0.2.</span> <span class="toc-text">2、HashMap的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%BD%93%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84hashcode%E7%9B%B8%E5%90%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.0.0.3.</span> <span class="toc-text">3、当两个对象的hashcode相同会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E4%BD%A0%E7%9F%A5%E9%81%93Hash%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%91%A2%EF%BC%9F"><span class="toc-number">6.0.0.4.</span> <span class="toc-text">4、你知道Hash的实现吗？为什么要这么实现呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9F"><span class="toc-number">6.0.0.5.</span> <span class="toc-text">5、为什么要用异或运算符？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81HashMap%E7%9A%84table%E7%9A%84%E5%AE%B9%E9%87%8F%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%EF%BC%9F"><span class="toc-number">6.0.0.6.</span> <span class="toc-text">6、HashMap的table的容量如何确定？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81loadFactor%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%AF%A5%E5%AE%B9%E9%87%8F%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%EF%BC%9F%E8%BF%99%E4%B8%AA%E5%8F%98%E5%8C%96%E4%BC%9A%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">6.0.0.7.</span> <span class="toc-text">7、loadFactor是什么？该容量如何变化？这个变化会带来什么问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80%EF%BC%9A"><span class="toc-number">6.0.0.7.1.</span> <span class="toc-text">问题一：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%9A"><span class="toc-number">6.0.0.7.2.</span> <span class="toc-text">问题二：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%89%EF%BC%9A"><span class="toc-number">6.0.0.7.3.</span> <span class="toc-text">问题三：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%A7%81%E8%A7%A3%EF%BC%9F"><span class="toc-number">6.0.0.8.</span> <span class="toc-text">8、说说你对红黑树的见解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81HashMap%E3%80%81linkedHashMap%E3%80%81treeMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.0.0.9.</span> <span class="toc-text">9、HashMap、linkedHashMap、treeMap的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81HashMap%E3%80%81linkedHashMap%E3%80%81treeMap%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">6.0.0.10.</span> <span class="toc-text">10、HashMap、linkedHashMap、treeMap使用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81%E5%8C%BA%E5%88%AB%EF%BC%9AHashMap%E2%80%94HashTable"><span class="toc-number">6.0.0.11.</span> <span class="toc-text">11、区别：HashMap—HashTable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81HashMap%E7%9A%84%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">6.0.0.12.</span> <span class="toc-text">12、HashMap的不安全体现在哪里？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81HashMap%E6%80%8E%E6%A0%B7%E8%A7%A3%E5%86%B3Hash%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-number">6.0.0.13.</span> <span class="toc-text">13、HashMap怎样解决Hash冲突？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81HashMap%E5%92%8CConcurrentHashMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.0.0.14.</span> <span class="toc-text">14、HashMap和ConcurrentHashMap的区别？</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E5%9B%9E%E9%A1%BE"><span class="toc-number">7.</span> <span class="toc-text">Java基础常见面试回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">Java常见面试题（上）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B8%B8%E8%AF%86"><span class="toc-number">7.1.1.</span> <span class="toc-text">基础概念和常识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">Java语言特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-SE-vs-Java-EE"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">Java SE vs Java EE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM-vs-JDK-vs-JRE"><span class="toc-number">7.1.1.3.</span> <span class="toc-text">JVM vs JDK vs JRE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F%E9%87%87%E7%94%A8%E5%AE%83%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.1.1.4.</span> <span class="toc-text">什么是字节码？采用它的好处是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Java%E8%AF%AD%E8%A8%80%E2%80%9C%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98%E2%80%9D%EF%BC%9F"><span class="toc-number">7.1.1.5.</span> <span class="toc-text">为什么说Java语言“编译与解释并存”？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOT%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%A8%E9%83%A8%E4%BD%BF%E7%94%A8AOT%E5%91%A2%EF%BC%9F"><span class="toc-number">7.1.1.6.</span> <span class="toc-text">AOT有什么优点？为什么不全部使用AOT呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-JDK-vs-Open-JDK"><span class="toc-number">7.1.1.7.</span> <span class="toc-text">Oracle JDK vs Open JDK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">7.1.1.8.</span> <span class="toc-text">&#x3D;&#x3D;Java和C++的区别？&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">7.1.2.</span> <span class="toc-text">基础语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">Java常见面试题（中）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">Java常见面试题（下）</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.pixabay.com/photo/2023/08/23/12/57/young-8208513_640.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 6wensitan</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/js/sun_moon.js" async></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>